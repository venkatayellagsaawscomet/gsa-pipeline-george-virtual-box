"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.isSuperObject = exports.ResourcePart = exports.HaveResourceAssertion = exports.haveResourceLike = exports.haveResource = exports.ABSENT = void 0;
const assertion_1 = require("../assertion");
const have_resource_matchers_1 = require("./have-resource-matchers");
/**
 * Magic value to signify that a certain key should be absent from the property bag.
 *
 * The property is either not present or set to `undefined.
 *
 * NOTE: `ABSENT` only works with the `haveResource()` and `haveResourceLike()`
 * assertions.
 */
exports.ABSENT = '{{ABSENT}}';
/**
 * An assertion to check whether a resource of a given type and with the given properties exists, disregarding properties
 *
 * @param resourceType the type of the resource that is expected to be present.
 * @param properties   the properties that the resource is expected to have. A function may be provided, in which case
 *                     it will be called with the properties of candidate resources and an ``InspectionFailure``
 *                     instance on which errors should be appended, and should return a truthy value to denote a match.
 * @param comparison   the entity that is being asserted against.
 * @param allowValueExtension if properties is an object, tells whether values must match exactly, or if they are
 *                     allowed to be supersets of the reference values. Meaningless if properties is a function.
 */
function haveResource(resourceType, properties, comparison, allowValueExtension = false) {
    return new HaveResourceAssertion(resourceType, properties, comparison, allowValueExtension);
}
exports.haveResource = haveResource;
/**
 * Sugar for calling ``haveResources`` with ``allowValueExtension`` set to ``true``.
 */
function haveResourceLike(resourceType, properties, comparison) {
    return haveResource(resourceType, properties, comparison, true);
}
exports.haveResourceLike = haveResourceLike;
class HaveResourceAssertion extends assertion_1.JestFriendlyAssertion {
    constructor(resourceType, properties, part, allowValueExtension = false) {
        super();
        this.resourceType = resourceType;
        this.inspected = [];
        this.matcher = isCallable(properties) ? properties :
            properties === undefined ? have_resource_matchers_1.anything() :
                allowValueExtension ? have_resource_matchers_1.deepObjectLike(properties) :
                    have_resource_matchers_1.objectLike(properties);
        this.part = part !== undefined ? part : ResourcePart.Properties;
    }
    assertUsing(inspector) {
        for (const logicalId of Object.keys(inspector.value.Resources || {})) {
            const resource = inspector.value.Resources[logicalId];
            if (resource.Type === this.resourceType) {
                const propsToCheck = this.part === ResourcePart.Properties ? resource.Properties : resource;
                // Pass inspection object as 2nd argument, initialize failure with default string,
                // to maintain backwards compatibility with old predicate API.
                const inspection = { resource, failureReason: 'Object did not match predicate' };
                if (have_resource_matchers_1.match(propsToCheck, this.matcher, inspection)) {
                    return true;
                }
                this.inspected.push(inspection);
            }
        }
        return false;
    }
    generateErrorMessage() {
        const lines = [];
        lines.push(`None of ${this.inspected.length} resources matches ${this.description}.`);
        for (const inspected of this.inspected) {
            lines.push(`- ${inspected.failureReason} in:`);
            lines.push(indent(4, JSON.stringify(inspected.resource, null, 2)));
        }
        return lines.join('\n');
    }
    assertOrThrow(inspector) {
        if (!this.assertUsing(inspector)) {
            throw new Error(this.generateErrorMessage());
        }
    }
    get description() {
        // eslint-disable-next-line max-len
        return `resource '${this.resourceType}' with ${JSON.stringify(this.matcher, undefined, 2)}`;
    }
}
exports.HaveResourceAssertion = HaveResourceAssertion;
function indent(n, s) {
    const prefix = ' '.repeat(n);
    return prefix + s.replace(/\n/g, '\n' + prefix);
}
/**
 * What part of the resource to compare
 */
var ResourcePart;
(function (ResourcePart) {
    /**
     * Only compare the resource's properties
     */
    ResourcePart[ResourcePart["Properties"] = 0] = "Properties";
    /**
     * Check the entire CloudFormation config
     *
     * (including UpdateConfig, DependsOn, etc.)
     */
    ResourcePart[ResourcePart["CompleteDefinition"] = 1] = "CompleteDefinition";
})(ResourcePart = exports.ResourcePart || (exports.ResourcePart = {}));
/**
 * Whether a value is a callable
 */
function isCallable(x) {
    return x && {}.toString.call(x) === '[object Function]';
}
/**
 * Return whether `superObj` is a super-object of `obj`.
 *
 * A super-object has the same or more property values, recursing into sub properties if ``allowValueExtension`` is true.
 *
 * At any point in the object, a value may be replaced with a function which will be used to check that particular field.
 * The type of a matcher function is expected to be of type PropertyMatcher.
 *
 * @deprecated - Use `objectLike` or a literal object instead.
 */
function isSuperObject(superObj, pattern, errors = [], allowValueExtension = false) {
    const matcher = allowValueExtension ? have_resource_matchers_1.deepObjectLike(pattern) : have_resource_matchers_1.objectLike(pattern);
    const inspection = { resource: superObj, failureReason: '' };
    const ret = have_resource_matchers_1.match(superObj, matcher, inspection);
    if (!ret) {
        errors.push(inspection.failureReason);
    }
    return ret;
}
exports.isSuperObject = isSuperObject;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaGF2ZS1yZXNvdXJjZS5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbImhhdmUtcmVzb3VyY2UudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7O0FBQUEsNENBQWdFO0FBRWhFLHFFQUF1RjtBQUV2Rjs7Ozs7OztHQU9HO0FBQ1UsUUFBQSxNQUFNLEdBQUcsWUFBWSxDQUFDO0FBRW5DOzs7Ozs7Ozs7O0dBVUc7QUFDSCxTQUFnQixZQUFZLENBQzFCLFlBQW9CLEVBQ3BCLFVBQWdCLEVBQ2hCLFVBQXlCLEVBQ3pCLHNCQUErQixLQUFLO0lBQ3BDLE9BQU8sSUFBSSxxQkFBcUIsQ0FBQyxZQUFZLEVBQUUsVUFBVSxFQUFFLFVBQVUsRUFBRSxtQkFBbUIsQ0FBQyxDQUFDO0FBQzlGLENBQUM7QUFORCxvQ0FNQztBQUVEOztHQUVHO0FBQ0gsU0FBZ0IsZ0JBQWdCLENBQzlCLFlBQW9CLEVBQ3BCLFVBQWdCLEVBQ2hCLFVBQXlCO0lBQ3pCLE9BQU8sWUFBWSxDQUFDLFlBQVksRUFBRSxVQUFVLEVBQUUsVUFBVSxFQUFFLElBQUksQ0FBQyxDQUFDO0FBQ2xFLENBQUM7QUFMRCw0Q0FLQztBQUlELE1BQWEscUJBQXNCLFNBQVEsaUNBQXFDO0lBSzlFLFlBQ21CLFlBQW9CLEVBQ3JDLFVBQWdCLEVBQ2hCLElBQW1CLEVBQ25CLHNCQUErQixLQUFLO1FBQ3BDLEtBQUssRUFBRSxDQUFDO1FBSlMsaUJBQVksR0FBWixZQUFZLENBQVE7UUFMdEIsY0FBUyxHQUF3QixFQUFFLENBQUM7UUFXbkQsSUFBSSxDQUFDLE9BQU8sR0FBRyxVQUFVLENBQUMsVUFBVSxDQUFDLENBQUMsQ0FBQyxDQUFDLFVBQVUsQ0FBQyxDQUFDO1lBQ2xELFVBQVUsS0FBSyxTQUFTLENBQUMsQ0FBQyxDQUFDLGlDQUFRLEVBQUUsQ0FBQyxDQUFDO2dCQUNyQyxtQkFBbUIsQ0FBQyxDQUFDLENBQUMsdUNBQWMsQ0FBQyxVQUFVLENBQUMsQ0FBQyxDQUFDO29CQUNoRCxtQ0FBVSxDQUFDLFVB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QjtBQUVEOztHQUVHO0FBQ0gsU0FBUyxVQUFVLENBQUMsQ0FBTTtJQUN4QixPQUFPLENBQUMsSUFBSSxFQUFFLENBQUMsUUFBUSxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsS0FBSyxtQkFBbUIsQ0FBQztBQUMxRCxDQUFDO0FBRUQ7Ozs7Ozs7OztHQVNHO0FBQ0gsU0FBZ0IsYUFBYSxDQUFDLFFBQWEsRUFBRSxPQUFZLEVBQUUsU0FBbUIsRUFBRSxFQUFFLHNCQUErQixLQUFLO0lBQ3BILE1BQU0sT0FBTyxHQUFHLG1CQUFtQixDQUFDLENBQUMsQ0FBQyx1Q0FBYyxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUMsQ0FBQyxtQ0FBVSxDQUFDLE9BQU8sQ0FBQyxDQUFDO0lBRXBGLE1BQU0sVUFBVSxHQUFzQixFQUFFLFFBQVEsRUFBRSxRQUFRLEVBQUUsYUFBYSxFQUFFLEVBQUUsRUFBRSxDQUFDO0lBQ2hGLE1BQU0sR0FBRyxHQUFHLDhCQUFLLENBQUMsUUFBUSxFQUFFLE9BQU8sRUFBRSxVQUFVLENBQUMsQ0FBQztJQUNqRCxJQUFJLENBQUMsR0FBRyxFQUFFO1FBQ1IsTUFBTSxDQUFDLElBQUksQ0FBQyxVQUFVLENBQUMsYUFBYSxDQUFDLENBQUM7S0FDdkM7SUFDRCxPQUFPLEdBQUcsQ0FBQztBQUNiLENBQUM7QUFURCxzQ0FTQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEFzc2VydGlvbiwgSmVzdEZyaWVuZGx5QXNzZXJ0aW9uIH0gZnJvbSAnLi4vYXNzZXJ0aW9uJztcbmltcG9ydCB7IFN0YWNrSW5zcGVjdG9yIH0gZnJvbSAnLi4vaW5zcGVjdG9yJztcbmltcG9ydCB7IGFueXRoaW5nLCBkZWVwT2JqZWN0TGlrZSwgbWF0Y2gsIG9iamVjdExpa2UgfSBmcm9tICcuL2hhdmUtcmVzb3VyY2UtbWF0Y2hlcnMnO1xuXG4vKipcbiAqIE1hZ2ljIHZhbHVlIHRvIHNpZ25pZnkgdGhhdCBhIGNlcnRhaW4ga2V5IHNob3VsZCBiZSBhYnNlbnQgZnJvbSB0aGUgcHJvcGVydHkgYmFnLlxuICpcbiAqIFRoZSBwcm9wZXJ0eSBpcyBlaXRoZXIgbm90IHByZXNlbnQgb3Igc2V0IHRvIGB1bmRlZmluZWQuXG4gKlxuICogTk9URTogYEFCU0VOVGAgb25seSB3b3JrcyB3aXRoIHRoZSBgaGF2ZVJlc291cmNlKClgIGFuZCBgaGF2ZVJlc291cmNlTGlrZSgpYFxuICogYXNzZXJ0aW9ucy5cbiAqL1xuZXhwb3J0IGNvbnN0IEFCU0VOVCA9ICd7e0FCU0VOVH19JztcblxuLyoqXG4gKiBBbiBhc3NlcnRpb24gdG8gY2hlY2sgd2hldGhlciBhIHJlc291cmNlIG9mIGEgZ2l2ZW4gdHlwZSBhbmQgd2l0aCB0aGUgZ2l2ZW4gcHJvcGVydGllcyBleGlzdHMsIGRpc3JlZ2FyZGluZyBwcm9wZXJ0aWVzXG4gKlxuICogQHBhcmFtIHJlc291cmNlVHlwZSB0aGUgdHlwZSBvZiB0aGUgcmVzb3VyY2UgdGhhdCBpcyBleHBlY3RlZCB0byBiZSBwcmVzZW50LlxuICogQHBhcmFtIHByb3BlcnRpZXMgICB0aGUgcHJvcGVydGllcyB0aGF0IHRoZSByZXNvdXJjZSBpcyBleHBlY3RlZCB0byBoYXZlLiBBIGZ1bmN0aW9uIG1heSBiZSBwcm92aWRlZCwgaW4gd2hpY2ggY2FzZVxuICogICAgICAgICAgICAgICAgICAgICBpdCB3aWxsIGJlIGNhbGxlZCB3aXRoIHRoZSBwcm9wZXJ0aWVzIG9mIGNhbmRpZGF0ZSByZXNvdXJjZXMgYW5kIGFuIGBgSW5zcGVjdGlvbkZhaWx1cmVgYFxuICogICAgICAgICAgICAgICAgICAgICBpbnN0YW5jZSBvbiB3aGljaCBlcnJvcnMgc2hvdWxkIGJlIGFwcGVuZGVkLCBhbmQgc2hvdWxkIHJldHVybiBhIHRydXRoeSB2YWx1ZSB0byBkZW5vdGUgYSBtYXRjaC5cbiAqIEBwYXJhbSBjb21wYXJpc29uICAgdGhlIGVudGl0eSB0aGF0IGlzIGJlaW5nIGFzc2VydGVkIGFnYWluc3QuXG4gKiBAcGFyYW0gYWxsb3dWYWx1ZUV4dGVuc2lvbiBpZiBwcm9wZXJ0aWVzIGlzIGFuIG9iamVjdCwgdGVsbHMgd2hldGhlciB2YWx1ZXMgbXVzdCBtYXRjaCBleGFjdGx5LCBvciBpZiB0aGV5IGFyZVxuICogICAgICAgICAgICAgICAgICAgICBhbGxvd2VkIHRvIGJlIHN1cGVyc2V0cyBvZiB0aGUgcmVmZXJlbmNlIHZhbHVlcy4gTWVhbmluZ2xlc3MgaWYgcHJvcGVydGllcyBpcyBhIGZ1bmN0aW9uLlxuICovXG5leHBvcnQgZnVuY3Rpb24gaGF2ZVJlc291cmNlKFxuICByZXNvdXJjZVR5cGU6IHN0cmluZyxcbiAgcHJvcGVydGllcz86IGFueSxcbiAgY29tcGFyaXNvbj86IFJlc291cmNlUGFydCxcbiAgYWxsb3dWYWx1ZUV4dGVuc2lvbjogYm9vbGVhbiA9IGZhbHNlKTogQXNzZXJ0aW9uPFN0YWNrSW5zcGVjdG9yPiB7XG4gIHJldHVybiBuZXcgSGF2ZVJlc291cmNlQXNzZXJ0aW9uKHJlc291cmNlVHlwZSwgcHJvcGVydGllcywgY29tcGFyaXNvbiwgYWxsb3dWYWx1ZUV4dGVuc2lvbik7XG59XG5cbi8qKlxuICogU3VnYXIgZm9yIGNhbGxpbmcgYGBoYXZlUmVzb3VyY2VzYGAgd2l0aCBgYGFsbG93VmFsdWVFeHRlbnNpb25gYCBzZXQgdG8gYGB0cnVlYGAuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBoYXZlUmVzb3VyY2VMaWtlKFxuICByZXNvdXJjZVR5cGU6IHN0cmluZyxcbiAgcHJvcGVydGllcz86IGFueSxcbiAgY29tcGFyaXNvbj86IFJlc291cmNlUGFydCkge1xuICByZXR1cm4gaGF2ZVJlc291cmNlKHJlc291cmNlVHlwZSwgcHJvcGVydGllcywgY29tcGFyaXNvbiwgdHJ1ZSk7XG59XG5cbmV4cG9ydCB0eXBlIFByb3BlcnR5TWF0Y2hlciA9IChwcm9wczogYW55LCBpbnNwZWN0aW9uOiBJbnNwZWN0aW9uRmFpbHVyZSkgPT4gYm9vbGVhbjtcblxuZXhwb3J0IGNsYXNzIEhhdmVSZXNvdXJjZUFzc2VydGlvbiBleHRlbmRzIEplc3RGcmllbmRseUFzc2VydGlvbjxTdGFja0luc3BlY3Rvcj4ge1xuICBwcml2YXRlIHJlYWRvbmx5IGluc3BlY3RlZDogSW5zcGVjdGlvbkZhaWx1cmVbXSA9IFtdO1xuICBwcml2YXRlIHJlYWRvbmx5IHBhcnQ6IFJlc291cmNlUGFydDtcbiAgcHJpdmF0ZSByZWFkb25seSBtYXRjaGVyOiBhbnk7XG5cbiAgY29uc3RydWN0b3IoXG4gICAgcHJpdmF0ZSByZWFkb25seSByZXNvdXJjZVR5cGU6IHN0cmluZyxcbiAgICBwcm9wZXJ0aWVzPzogYW55LFxuICAgIHBhcnQ/OiBSZXNvdXJjZVBhcnQsXG4gICAgYWxsb3dWYWx1ZUV4dGVuc2lvbjogYm9vbGVhbiA9IGZhbHNlKSB7XG4gICAgc3VwZXIoKTtcblxuICAgIHRoaXMubWF0Y2hlciA9IGlzQ2FsbGFibGUocHJvcGVydGllcykgPyBwcm9wZXJ0aWVzIDpcbiAgICAgIHByb3BlcnRpZXMgPT09IHVuZGVmaW5lZCA/IGFueXRoaW5nKCkgOlxuICAgICAgICBhbGxvd1ZhbHVlRXh0ZW5zaW9uID8gZGVlcE9iamVjdExpa2UocHJvcGVydGllcykgOlxuICAgICAgICAgIG9iamVjdExpa2UocHJvcGVydGllcyk7XG4gICAgdGhpcy5wYXJ0ID0gcGFydCAhPT0gdW5kZWZpbmVkID8gcGFydCA6IFJlc291cmNlUGFydC5Qcm9wZXJ0aWVzO1xuICB9XG5cbiAgcHVibGljIGFzc2VydFVzaW5nKGluc3BlY3RvcjogU3RhY2tJbnNwZWN0b3IpOiBib29sZWFuIHtcbiAgICBmb3IgKGNvbnN0IGxvZ2ljYWxJZCBvZiBPYmplY3Qua2V5cyhpbnNwZWN0b3IudmFsdWUuUmVzb3VyY2VzIHx8IHt9KSkge1xuICAgICAgY29uc3QgcmVzb3VyY2UgPSBpbnNwZWN0b3IudmFsdWUuUmVzb3VyY2VzW2xvZ2ljYWxJZF07XG4gICAgICBpZiAocmVzb3VyY2UuVHlwZSA9PT0gdGhpcy5yZXNvdXJjZVR5cGUpIHtcbiAgICAgICAgY29uc3QgcHJvcHNUb0NoZWNrID0gdGhpcy5wYXJ0ID09PSBSZXNvdXJjZVBhcnQuUHJvcGVydGllcyA/IHJlc291cmNlLlByb3BlcnRpZXMgOiByZXNvdXJjZTtcblxuICAgICAgICAvLyBQYXNzIGluc3BlY3Rpb24gb2JqZWN0IGFzIDJuZCBhcmd1bWVudCwgaW5pdGlhbGl6ZSBmYWlsdXJlIHdpdGggZGVmYXVsdCBzdHJpbmcsXG4gICAgICAgIC8vIHRvIG1haW50YWluIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5IHdpdGggb2xkIHByZWRpY2F0ZSBBUEkuXG4gICAgICAgIGNvbnN0IGluc3BlY3Rpb24gPSB7IHJlc291cmNlLCBmYWlsdXJlUmVhc29uOiAnT2JqZWN0IGRpZCBub3QgbWF0Y2ggcHJlZGljYXRlJyB9O1xuXG4gICAgICAgIGlmIChtYXRjaChwcm9wc1RvQ2hlY2ssIHRoaXMubWF0Y2hlciwgaW5zcGVjdGlvbikpIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuaW5zcGVjdGVkLnB1c2goaW5zcGVjdGlvbik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcHVibGljIGdlbmVyYXRlRXJyb3JNZXNzYWdlKCkge1xuICAgIGNvbnN0IGxpbmVzOiBzdHJpbmdbXSA9IFtdO1xuICAgIGxpbmVzLnB1c2goYE5vbmUgb2YgJHt0aGlzLmluc3BlY3RlZC5sZW5ndGh9IHJlc291cmNlcyBtYXRjaGVzICR7dGhpcy5kZXNjcmlwdGlvbn0uYCk7XG5cbiAgICBmb3IgKGNvbnN0IGluc3BlY3RlZCBvZiB0aGlzLmluc3BlY3RlZCkge1xuICAgICAgbGluZXMucHVzaChgLSAke2luc3BlY3RlZC5mYWlsdXJlUmVhc29ufSBpbjpgKTtcbiAgICAgIGxpbmVzLnB1c2goaW5kZW50KDQsIEpTT04uc3RyaW5naWZ5KGluc3BlY3RlZC5yZXNvdXJjZSwgbnVsbCwgMikpKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbGluZXMuam9pbignXFxuJyk7XG4gIH1cblxuICBwdWJsaWMgYXNzZXJ0T3JUaHJvdyhpbnNwZWN0b3I6IFN0YWNrSW5zcGVjdG9yKSB7XG4gICAgaWYgKCF0aGlzLmFzc2VydFVzaW5nKGluc3BlY3RvcikpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcih0aGlzLmdlbmVyYXRlRXJyb3JNZXNzYWdlKCkpO1xuICAgIH1cbiAgfVxuXG4gIHB1YmxpYyBnZXQgZGVzY3JpcHRpb24oKTogc3RyaW5nIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbWF4LWxlblxuICAgIHJldHVybiBgcmVzb3VyY2UgJyR7dGhpcy5yZXNvdXJjZVR5cGV9JyB3aXRoICR7SlNPTi5zdHJpbmdpZnkodGhpcy5tYXRjaGVyLCB1bmRlZmluZWQsIDIpfWA7XG4gIH1cbn1cblxuZnVuY3Rpb24gaW5kZW50KG46IG51bWJlciwgczogc3RyaW5nKSB7XG4gIGNvbnN0IHByZWZpeCA9ICcgJy5yZXBlYXQobik7XG4gIHJldHVybiBwcmVmaXggKyBzLnJlcGxhY2UoL1xcbi9nLCAnXFxuJyArIHByZWZpeCk7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgSW5zcGVjdGlvbkZhaWx1cmUge1xuICByZXNvdXJjZTogYW55O1xuICBmYWlsdXJlUmVhc29uOiBzdHJpbmc7XG59XG5cbi8qKlxuICogV2hhdCBwYXJ0IG9mIHRoZSByZXNvdXJjZSB0byBjb21wYXJlXG4gKi9cbmV4cG9ydCBlbnVtIFJlc291cmNlUGFydCB7XG4gIC8qKlxuICAgKiBPbmx5IGNvbXBhcmUgdGhlIHJlc291cmNlJ3MgcHJvcGVydGllc1xuICAgKi9cbiAgUHJvcGVydGllcyxcblxuICAvKipcbiAgICogQ2hlY2sgdGhlIGVudGlyZSBDbG91ZEZvcm1hdGlvbiBjb25maWdcbiAgICpcbiAgICogKGluY2x1ZGluZyBVcGRhdGVDb25maWcsIERlcGVuZHNPbiwgZXRjLilcbiAgICovXG4gIENvbXBsZXRlRGVmaW5pdGlvblxufVxuXG4vKipcbiAqIFdoZXRoZXIgYSB2YWx1ZSBpcyBhIGNhbGxhYmxlXG4gKi9cbmZ1bmN0aW9uIGlzQ2FsbGFibGUoeDogYW55KTogeCBpcyAoKC4uLmFyZ3M6IGFueVtdKSA9PiBhbnkpIHtcbiAgcmV0dXJuIHggJiYge30udG9TdHJpbmcuY2FsbCh4KSA9PT0gJ1tvYmplY3QgRnVuY3Rpb25dJztcbn1cblxuLyoqXG4gKiBSZXR1cm4gd2hldGhlciBgc3VwZXJPYmpgIGlzIGEgc3VwZXItb2JqZWN0IG9mIGBvYmpgLlxuICpcbiAqIEEgc3VwZXItb2JqZWN0IGhhcyB0aGUgc2FtZSBvciBtb3JlIHByb3BlcnR5IHZhbHVlcywgcmVjdXJzaW5nIGludG8gc3ViIHByb3BlcnRpZXMgaWYgYGBhbGxvd1ZhbHVlRXh0ZW5zaW9uYGAgaXMgdHJ1ZS5cbiAqXG4gKiBBdCBhbnkgcG9pbnQgaW4gdGhlIG9iamVjdCwgYSB2YWx1ZSBtYXkgYmUgcmVwbGFjZWQgd2l0aCBhIGZ1bmN0aW9uIHdoaWNoIHdpbGwgYmUgdXNlZCB0byBjaGVjayB0aGF0IHBhcnRpY3VsYXIgZmllbGQuXG4gKiBUaGUgdHlwZSBvZiBhIG1hdGNoZXIgZnVuY3Rpb24gaXMgZXhwZWN0ZWQgdG8gYmUgb2YgdHlwZSBQcm9wZXJ0eU1hdGNoZXIuXG4gKlxuICogQGRlcHJlY2F0ZWQgLSBVc2UgYG9iamVjdExpa2VgIG9yIGEgbGl0ZXJhbCBvYmplY3QgaW5zdGVhZC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzU3VwZXJPYmplY3Qoc3VwZXJPYmo6IGFueSwgcGF0dGVybjogYW55LCBlcnJvcnM6IHN0cmluZ1tdID0gW10sIGFsbG93VmFsdWVFeHRlbnNpb246IGJvb2xlYW4gPSBmYWxzZSk6IGJvb2xlYW4ge1xuICBjb25zdCBtYXRjaGVyID0gYWxsb3dWYWx1ZUV4dGVuc2lvbiA/IGRlZXBPYmplY3RMaWtlKHBhdHRlcm4pIDogb2JqZWN0TGlrZShwYXR0ZXJuKTtcblxuICBjb25zdCBpbnNwZWN0aW9uOiBJbnNwZWN0aW9uRmFpbHVyZSA9IHsgcmVzb3VyY2U6IHN1cGVyT2JqLCBmYWlsdXJlUmVhc29uOiAnJyB9O1xuICBjb25zdCByZXQgPSBtYXRjaChzdXBlck9iaiwgbWF0Y2hlciwgaW5zcGVjdGlvbik7XG4gIGlmICghcmV0KSB7XG4gICAgZXJyb3JzLnB1c2goaW5zcGVjdGlvbi5mYWlsdXJlUmVhc29uKTtcbiAgfVxuICByZXR1cm4gcmV0O1xufVxuIl19