"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.outputFromStack = exports.deleteBucket = exports.deleteImageRepository = exports.emptyBucket = exports.sleep = exports.retry = exports.isBucketMissingError = exports.isStackMissingError = exports.stackStatus = exports.deleteStacks = exports.sts = exports.lambda = exports.iam = exports.sns = exports.ecr = exports.s3 = exports.cloudFormation = exports.testEnv = void 0;
const AWS = require("aws-sdk");
const cdk_helpers_1 = require("./cdk-helpers");
exports.testEnv = async () => {
    var _a, _b;
    const response = await new AWS.STS().getCallerIdentity().promise();
    const ret = {
        account: response.Account,
        region: (_b = (_a = process.env.AWS_REGION) !== null && _a !== void 0 ? _a : process.env.AWS_DEFAULT_REGION) !== null && _b !== void 0 ? _b : 'us-east-1',
    };
    exports.testEnv = () => Promise.resolve(ret);
    return ret;
};
exports.cloudFormation = makeAwsCaller(AWS.CloudFormation);
exports.s3 = makeAwsCaller(AWS.S3);
exports.ecr = makeAwsCaller(AWS.ECR);
exports.sns = makeAwsCaller(AWS.SNS);
exports.iam = makeAwsCaller(AWS.IAM);
exports.lambda = makeAwsCaller(AWS.Lambda);
exports.sts = makeAwsCaller(AWS.STS);
/**
 * Perform an AWS call from nothing
 *
 * Create the correct client, do the call and resole the promise().
 */
async function awsCall(ctor, call, request) {
    const env = await exports.testEnv();
    const cfn = new ctor({ region: env.region, maxRetries: 6, retryDelayOptions: { base: 500 } });
    const response = cfn[call](request);
    try {
        return await response.promise();
    }
    catch (e) {
        const newErr = new Error(`${call}(${JSON.stringify(request)}): ${e.message}`);
        newErr.code = e.code;
        throw newErr;
    }
}
/**
 * Factory function to invoke 'awsCall' for specific services.
 *
 * Not strictly necessary but calling this replaces a whole bunch of annoying generics you otherwise have to type:
 *
 * ```ts
 * export function cloudFormation<
 *   C extends keyof ServiceCalls<AWS.CloudFormation>,
 * >(call: C, request: First<ServiceCalls<AWS.CloudFormation>[C]>): Promise<Second<ServiceCalls<AWS.CloudFormation>[C]>> {
 *   return awsCall(AWS.CloudFormation, call, request);
 * }
 * ```
 */
function makeAwsCaller(ctor) {
    return (call, request) => {
        return awsCall(ctor, call, request);
    };
}
async function deleteStacks(...stackNames) {
    if (stackNames.length === 0) {
        return;
    }
    for (const stackName of stackNames) {
        await exports.cloudFormation('updateTerminationProtection', {
            EnableTerminationProtection: false,
            StackName: stackName,
        });
        await exports.cloudFormation('deleteStack', {
            StackName: stackName,
        });
    }
    await retry(`Deleting ${stackNames}`, retry.forSeconds(600), async () => {
        for (const stackName of stackNames) {
            const status = await stackStatus(stackName);
            if (status !== undefined && status.endsWith('_FAILED')) {
                throw retry.abort(new Error(`'${stackName}' is in state '${status}'`));
            }
            if (status !== undefined) {
                throw new Error(`Delete of '${stackName}' not complete yet`);
            }
        }
    });
}
exports.deleteStacks = deleteStacks;
async function stackStatus(stackName) {
    var _a;
    try {
        return (_a = (await exports.cloudFormation('describeStacks', { StackName: stackName })).Stacks) === null || _a === void 0 ? void 0 : _a[0].StackStatus;
    }
    catch (e) {
        if (isStackMissingError(e)) {
            return undefined;
        }
        throw e;
    }
}
exports.stackStatus = stackStatus;
function isStackMissingError(e) {
    return e.message.indexOf('does not exist') > -1;
}
exports.isStackMissingError = isStackMissingError;
function isBucketMissingError(e) {
    return e.message.indexOf('does not exist') > -1;
}
exports.isBucketMissingError = isBucketMissingError;
/**
 * Retry an async operation until a deadline is hit.
 *
 * Use `retry.forSeconds()` to construct a deadline relative to right now.
 *
 * Exceptions will cause the operation to retry. Use `retry.abort` to annotate an exception
 * to stop the retry and end in a failure.
 */
async function retry(operation, deadline, block) {
    let i = 0;
    cdk_helpers_1.log(`💈 ${operation}`);
    while (true) {
        try {
            i++;
            const ret = await block();
            cdk_helpers_1.log(`💈 ${operation}: succeeded after ${i} attempts`);
            return ret;
        }
        catch (e) {
            if (e.abort || Date.now() > deadline.getTime()) {
                throw new Error(`${operation}: did not succeed after ${i} attempts: ${e}`);
            }
            cdk_helpers_1.log(`⏳ ${operation} (${e.message})`);
            await sleep(5000);
        }
    }
}
exports.retry = retry;
/**
 * Make a deadline for the `retry` function relative to the current time.
 */
retry.forSeconds = (seconds) => {
    return new Date(Date.now() + seconds * 1000);
};
/**
 * Annotate an error to stop the retrying
 */
retry.abort = (e) => {
    e.abort = true;
    return e;
};
async function sleep(ms) {
    return new Promise(ok => setTimeout(ok, ms));
}
exports.sleep = sleep;
async function emptyBucket(bucketName) {
    const objects = await exports.s3('listObjects', { Bucket: bucketName });
    const deletes = (objects.Contents || []).map(obj => obj.Key || '').filter(d => !!d);
    if (deletes.length === 0) {
        return Promise.resolve();
    }
    return exports.s3('deleteObjects', {
        Bucket: bucketName,
        Delete: {
            Objects: deletes.map(d => ({ Key: d })),
            Quiet: false,
        },
    });
}
exports.emptyBucket = emptyBucket;
async function deleteImageRepository(repositoryName) {
    await exports.ecr('deleteRepository', { repositoryName, force: true });
}
exports.deleteImageRepository = deleteImageRepository;
async function deleteBucket(bucketName) {
    try {
        await emptyBucket(bucketName);
        await exports.s3('deleteBucket', {
            Bucket: bucketName,
        });
    }
    catch (e) {
        if (isBucketMissingError(e)) {
            return;
        }
        throw e;
    }
}
exports.deleteBucket = deleteBucket;
function outputFromStack(key, stack) {
    var _a, _b;
    return (_b = ((_a = stack.Outputs) !== null && _a !== void 0 ? _a : []).find(o => o.OutputKey === key)) === null || _b === void 0 ? void 0 : _b.OutputValue;
}
exports.outputFromStack = outputFromStack;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYXdzLWhlbHBlcnMuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJhd3MtaGVscGVycy50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7QUFBQSwrQkFBK0I7QUFDL0IsK0NBQW9DO0FBT3pCLFFBQUEsT0FBTyxHQUFHLEtBQUssSUFBa0IsRUFBRTs7SUFDNUMsTUFBTSxRQUFRLEdBQUcsTUFBTSxJQUFJLEdBQUcsQ0FBQyxHQUFHLEVBQUUsQ0FBQyxpQkFBaUIsRUFBRSxDQUFDLE9BQU8sRUFBRSxDQUFDO0lBRW5FLE1BQU0sR0FBRyxHQUFRO1FBQ2YsT0FBTyxFQUFFLFFBQVEsQ0FBQyxPQUFRO1FBQzFCLE1BQU0sY0FBRSxPQUFPLENBQUMsR0FBRyxDQUFDLFVBQVUsbUNBQUksT0FBTyxDQUFDLEdBQUcsQ0FBQyxrQkFBa0IsbUNBQUksV0FBVztLQUNoRixDQUFDO0lBRUYsZUFBTyxHQUFHLEdBQUcsRUFBRSxDQUFDLE9BQU8sQ0FBQyxPQUFPLENBQUMsR0FBRyxDQUFDLENBQUM7SUFDckMsT0FBTyxHQUFHLENBQUM7QUFDYixDQUFDLENBQUM7QUFFVyxRQUFBLGNBQWMsR0FBRyxhQUFhLENBQUMsR0FBRyxDQUFDLGNBQWMsQ0FBQyxDQUFDO0FBQ25ELFFBQUEsRUFBRSxHQUFHLGFBQWEsQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLENBQUM7QUFDM0IsUUFBQSxHQUFHLEdBQUcsYUFBYSxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQztBQUM3QixRQUFBLEdBQUcsR0FBRyxhQUFhLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxDQUFDO0FBQzdCLFFBQUEsR0FBRyxHQUFHLGFBQWEsQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLENBQUM7QUFDN0IsUUFBQSxNQUFNLEdBQUcsYUFBYSxDQUFDLEdBQUcsQ0FBQyxNQUFNLENBQUMsQ0FBQztBQUNuQyxRQUFBLEdBQUcsR0FBRyxhQUFhLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxDQUFDO0FB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QyxDQUFDLEVBQUUsR0FBRyxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUM7WUFDdkMsS0FBSyxFQUFFLEtBQUs7U0FDYjtLQUNGLENBQUMsQ0FBQztBQUNMLENBQUM7QUFiRCxrQ0FhQztBQUVNLEtBQUssVUFBVSxxQkFBcUIsQ0FBQyxjQUFzQjtJQUNoRSxNQUFNLFdBQUcsQ0FBQyxrQkFBa0IsRUFBRSxFQUFFLGNBQWMsRUFBRSxLQUFLLEVBQUUsSUFBSSxFQUFFLENBQUMsQ0FBQztBQUNqRSxDQUFDO0FBRkQsc0RBRUM7QUFFTSxLQUFLLFVBQVUsWUFBWSxDQUFDLFVBQWtCO0lBQ25ELElBQUk7UUFDRixNQUFNLFdBQVcsQ0FBQyxVQUFVLENBQUMsQ0FBQztRQUM5QixNQUFNLFVBQUUsQ0FBQyxjQUFjLEVBQUU7WUFDdkIsTUFBTSxFQUFFLFVBQVU7U0FDbkIsQ0FBQyxDQUFDO0tBQ0o7SUFBQyxPQUFPLENBQUMsRUFBRTtRQUNWLElBQUksb0JBQW9CLENBQUMsQ0FBQyxDQUFDLEVBQUU7WUFBRSxPQUFPO1NBQUU7UUFDeEMsTUFBTSxDQUFDLENBQUM7S0FDVDtBQUNILENBQUM7QUFWRCxvQ0FVQztBQUVELFNBQWdCLGVBQWUsQ0FBQyxHQUFXLEVBQUUsS0FBK0I7O0lBQzFFLGFBQU8sT0FBQyxLQUFLLENBQUMsT0FBTyxtQ0FBSSxFQUFFLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsU0FBUyxLQUFLLEdBQUcsQ0FBQywwQ0FBRSxXQUFXLENBQUM7QUFDM0UsQ0FBQztBQUZELDBDQUVDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICogYXMgQVdTIGZyb20gJ2F3cy1zZGsnO1xuaW1wb3J0IHsgbG9nIH0gZnJvbSAnLi9jZGstaGVscGVycyc7XG5cbmludGVyZmFjZSBFbnYge1xuICBhY2NvdW50OiBzdHJpbmc7XG4gIHJlZ2lvbjogc3RyaW5nO1xufVxuXG5leHBvcnQgbGV0IHRlc3RFbnYgPSBhc3luYyAoKTogUHJvbWlzZTxFbnY+ID0+IHtcbiAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBuZXcgQVdTLlNUUygpLmdldENhbGxlcklkZW50aXR5KCkucHJvbWlzZSgpO1xuXG4gIGNvbnN0IHJldDogRW52ID0ge1xuICAgIGFjY291bnQ6IHJlc3BvbnNlLkFjY291bnQhLFxuICAgIHJlZ2lvbjogcHJvY2Vzcy5lbnYuQVdTX1JFR0lPTiA/PyBwcm9jZXNzLmVudi5BV1NfREVGQVVMVF9SRUdJT04gPz8gJ3VzLWVhc3QtMScsXG4gIH07XG5cbiAgdGVzdEVudiA9ICgpID0+IFByb21pc2UucmVzb2x2ZShyZXQpO1xuICByZXR1cm4gcmV0O1xufTtcblxuZXhwb3J0IGNvbnN0IGNsb3VkRm9ybWF0aW9uID0gbWFrZUF3c0NhbGxlcihBV1MuQ2xvdWRGb3JtYXRpb24pO1xuZXhwb3J0IGNvbnN0IHMzID0gbWFrZUF3c0NhbGxlcihBV1MuUzMpO1xuZXhwb3J0IGNvbnN0IGVjciA9IG1ha2VBd3NDYWxsZXIoQVdTLkVDUik7XG5leHBvcnQgY29uc3Qgc25zID0gbWFrZUF3c0NhbGxlcihBV1MuU05TKTtcbmV4cG9ydCBjb25zdCBpYW0gPSBtYWtlQXdzQ2FsbGVyKEFXUy5JQU0pO1xuZXhwb3J0IGNvbnN0IGxhbWJkYSA9IG1ha2VBd3NDYWxsZXIoQVdTLkxhbWJkYSk7XG5leHBvcnQgY29uc3Qgc3RzID0gbWFrZUF3c0NhbGxlcihBV1MuU1RTKTtcblxuLyoqXG4gKiBQZXJmb3JtIGFuIEFXUyBjYWxsIGZyb20gbm90aGluZ1xuICpcbiAqIENyZWF0ZSB0aGUgY29ycmVjdCBjbGllbnQsIGRvIHRoZSBjYWxsIGFuZCByZXNvbGUgdGhlIHByb21pc2UoKS5cbiAqL1xuYXN5bmMgZnVuY3Rpb24gYXdzQ2FsbDxcbiAgQSBleHRlbmRzIEFXUy5TZXJ2aWNlLFxuICBCIGV4dGVuZHMga2V5b2YgU2VydmljZUNhbGxzPEE+LFxuPihjdG9yOiBuZXcgKGNvbmZpZzogYW55KSA9PiBBLCBjYWxsOiBCLCByZXF1ZXN0OiBGaXJzdDxTZXJ2aWNlQ2FsbHM8QT5bQl0+KTogUHJvbWlzZTxTZWNvbmQ8U2VydmljZUNhbGxzPEE+W0JdPj4ge1xuICBjb25zdCBlbnYgPSBhd2FpdCB0ZXN0RW52KCk7XG4gIGNvbnN0IGNmbiA9IG5ldyBjdG9yKHsgcmVnaW9uOiBlbnYucmVnaW9uLCBtYXhSZXRyaWVzOiA2LCByZXRyeURlbGF5T3B0aW9uczogeyBiYXNlOiA1MDAgfSB9KTtcbiAgY29uc3QgcmVzcG9uc2UgPSBjZm5bY2FsbF0ocmVxdWVzdCk7XG4gIHRyeSB7XG4gICAgcmV0dXJuIGF3YWl0IHJlc3BvbnNlLnByb21pc2UoKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIGNvbnN0IG5ld0VyciA9IG5ldyBFcnJvcihgJHtjYWxsfSgke0pTT04uc3RyaW5naWZ5KHJlcXVlc3QpfSk6ICR7ZS5tZXNzYWdlfWApO1xuICAgIChuZXdFcnIgYXMgYW55KS5jb2RlID0gZS5jb2RlO1xuICAgIHRocm93IG5ld0VycjtcbiAgfVxufVxuXG4vKipcbiAqIEZhY3RvcnkgZnVuY3Rpb24gdG8gaW52b2tlICdhd3NDYWxsJyBmb3Igc3BlY2lmaWMgc2VydmljZXMuXG4gKlxuICogTm90IHN0cmljdGx5IG5lY2Vzc2FyeSBidXQgY2FsbGluZyB0aGlzIHJlcGxhY2VzIGEgd2hvbGUgYnVuY2ggb2YgYW5ub3lpbmcgZ2VuZXJpY3MgeW91IG90aGVyd2lzZSBoYXZlIHRvIHR5cGU6XG4gKlxuICogYGBgdHNcbiAqIGV4cG9ydCBmdW5jdGlvbiBjbG91ZEZvcm1hdGlvbjxcbiAqICAgQyBleHRlbmRzIGtleW9mIFNlcnZpY2VDYWxsczxBV1MuQ2xvdWRGb3JtYXRpb24+LFxuICogPihjYWxsOiBDLCByZXF1ZXN0OiBGaXJzdDxTZXJ2aWNlQ2FsbHM8QVdTLkNsb3VkRm9ybWF0aW9uPltDXT4pOiBQcm9taXNlPFNlY29uZDxTZXJ2aWNlQ2FsbHM8QVdTLkNsb3VkRm9ybWF0aW9uPltDXT4+IHtcbiAqICAgcmV0dXJuIGF3c0NhbGwoQVdTLkNsb3VkRm9ybWF0aW9uLCBjYWxsLCByZXF1ZXN0KTtcbiAqIH1cbiAqIGBgYFxuICovXG5mdW5jdGlvbiBtYWtlQXdzQ2FsbGVyPEEgZXh0ZW5kcyBBV1MuU2VydmljZT4oY3RvcjogbmV3IChjb25maWc6IGFueSkgPT4gQSkge1xuICByZXR1cm4gPEIgZXh0ZW5kcyBrZXlvZiBTZXJ2aWNlQ2FsbHM8QT4+KGNhbGw6IEIsIHJlcXVlc3Q6IEZpcnN0PFNlcnZpY2VDYWxsczxBPltCXT4pOiBQcm9taXNlPFNlY29uZDxTZXJ2aWNlQ2FsbHM8QT5bQl0+PiA9PiB7XG4gICAgcmV0dXJuIGF3c0NhbGwoY3RvciwgY2FsbCwgcmVxdWVzdCk7XG4gIH07XG59XG5cbnR5cGUgU2VydmljZUNhbGxzPFQ+ID0gTm9OYXlOZXZlcjxTaW1wbGlmaWVkU2VydmljZTxUPj47XG4vLyBNYXAgZXZlciBtZW1iZXIgaW4gdGhlIHR5cGUgdG8gdGhlIGltcG9ydGFudCBBV1MgY2FsbCBvdmVybG9hZCwgb3IgdG8gJ25ldmVyJ1xudHlwZSBTaW1wbGlmaWVkU2VydmljZTxUPiA9IHtbayBpbiBrZXlvZiBUXTogQXdzQ2FsbElPPFRba10+fTtcbi8vIFJlbW92ZSBhbGwgJ25ldmVyJyB0eXBlcyBmcm9tIGFuIG9iamVjdCB0eXBlXG50eXBlIE5vTmF5TmV2ZXI8VD4gPSBQaWNrPFQsIHtbayBpbiBrZXlvZiBUXTogVFtrXSBleHRlbmRzIG5ldmVyID8gbmV2ZXIgOiBrIH1ba2V5b2YgVF0+O1xuXG4vLyBCZWNhdXNlIG9mIHRoZSBvdmVybG9hZHMgYW4gQVdTIGhhbmRsZXIgdHlwZSBsb29rcyBsaWtlIHRoaXM6XG4vL1xuLy8gICB7XG4vLyAgICAgIChwYXJhbXM6IElOUFVUU1RSVUNULCBjYWxsYmFjaz86ICgoZXJyOiBBV1NFcnJvciwgZGF0YToge30pID0+IHZvaWQpIHwgdW5kZWZpbmVkKTogUmVxdWVzdDxPVVRQVVQsIC4uLj47XG4vLyAgICAgIChjYWxsYmFjaz86ICgoZXJyOiBBV1MuQVdTRXJyb3IsIGRhdGE6IHt9KSA9PiB2b2lkKSB8IHVuZGVmaW5lZCk6IEFXUy5SZXF1ZXN0PC4uLj47XG4vLyAgIH1cbi8vXG4vLyBHZXQgdGhlIGZpcnN0IG92ZXJsb2FkIGFuZCBleHRyYWN0IHRoZSBpbnB1dCBhbmQgb3V0cHV0IHN0cnVjdCB0eXBlc1xudHlwZSBBd3NDYWxsSU88VD4gPVxuICBUIGV4dGVuZHMge1xuICAgIChhcmdzOiBpbmZlciBJTlBVVCwgY2FsbGJhY2s/OiAoKGVycjogQVdTLkFXU0Vycm9yLCBkYXRhOiBhbnkpID0+IHZvaWQpIHwgdW5kZWZpbmVkKTogQVdTLlJlcXVlc3Q8aW5mZXIgT1VUUFVULCBBV1MuQVdTRXJyb3I+O1xuICAgIChjYWxsYmFjaz86ICgoZXJyOiBBV1MuQVdTRXJyb3IsIGRhdGE6IHt9KSA9PiB2b2lkKSB8IHVuZGVmaW5lZCk6IEFXUy5SZXF1ZXN0PGFueSwgYW55PjtcbiAgfSA/IFtJTlBVVCwgT1VUUFVUXSA6IG5ldmVyO1xuXG50eXBlIEZpcnN0PFQ+ID0gVCBleHRlbmRzIFthbnksIGFueV0gPyBUWzBdIDogbmV2ZXI7XG50eXBlIFNlY29uZDxUPiA9IFQgZXh0ZW5kcyBbYW55LCBhbnldID8gVFsxXSA6IG5ldmVyO1xuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZGVsZXRlU3RhY2tzKC4uLnN0YWNrTmFtZXM6IHN0cmluZ1tdKSB7XG4gIGlmIChzdGFja05hbWVzLmxlbmd0aCA9PT0gMCkgeyByZXR1cm47IH1cblxuICBmb3IgKGNvbnN0IHN0YWNrTmFtZSBvZiBzdGFja05hbWVzKSB7XG4gICAgYXdhaXQgY2xvdWRGb3JtYXRpb24oJ3VwZGF0ZVRlcm1pbmF0aW9uUHJvdGVjdGlvbicsIHtcbiAgICAgIEVuYWJsZVRlcm1pbmF0aW9uUHJvdGVjdGlvbjogZmFsc2UsXG4gICAgICBTdGFja05hbWU6IHN0YWNrTmFtZSxcbiAgICB9KTtcbiAgICBhd2FpdCBjbG91ZEZvcm1hdGlvbignZGVsZXRlU3RhY2snLCB7XG4gICAgICBTdGFja05hbWU6IHN0YWNrTmFtZSxcbiAgICB9KTtcbiAgfVxuXG4gIGF3YWl0IHJldHJ5KGBEZWxldGluZyAke3N0YWNrTmFtZXN9YCwgcmV0cnkuZm9yU2Vjb25kcyg2MDApLCBhc3luYyAoKSA9PiB7XG4gICAgZm9yIChjb25zdCBzdGFja05hbWUgb2Ygc3RhY2tOYW1lcykge1xuICAgICAgY29uc3Qgc3RhdHVzID0gYXdhaXQgc3RhY2tTdGF0dXMoc3RhY2tOYW1lKTtcbiAgICAgIGlmIChzdGF0dXMgIT09IHVuZGVmaW5lZCAmJiBzdGF0dXMuZW5kc1dpdGgoJ19GQUlMRUQnKSkge1xuICAgICAgICB0aHJvdyByZXRyeS5hYm9ydChuZXcgRXJyb3IoYCcke3N0YWNrTmFtZX0nIGlzIGluIHN0YXRlICcke3N0YXR1c30nYCkpO1xuICAgICAgfVxuICAgICAgaWYgKHN0YXR1cyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgRGVsZXRlIG9mICcke3N0YWNrTmFtZX0nIG5vdCBjb21wbGV0ZSB5ZXRgKTtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gc3RhY2tTdGF0dXMoc3RhY2tOYW1lOiBzdHJpbmcpOiBQcm9taXNlPHN0cmluZyB8IHVuZGVmaW5lZD4ge1xuICB0cnkge1xuICAgIHJldHVybiAoYXdhaXQgY2xvdWRGb3JtYXRpb24oJ2Rlc2NyaWJlU3RhY2tzJywgeyBTdGFja05hbWU6IHN0YWNrTmFtZSB9KSkuU3RhY2tzPy5bMF0uU3RhY2tTdGF0dXM7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBpZiAoaXNTdGFja01pc3NpbmdFcnJvcihlKSkgeyByZXR1cm4gdW5kZWZpbmVkOyB9XG4gICAgdGhyb3cgZTtcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gaXNTdGFja01pc3NpbmdFcnJvcihlOiBFcnJvcikge1xuICByZXR1cm4gZS5tZXNzYWdlLmluZGV4T2YoJ2RvZXMgbm90IGV4aXN0JykgPiAtMTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGlzQnVja2V0TWlzc2luZ0Vycm9yKGU6IEVycm9yKSB7XG4gIHJldHVybiBlLm1lc3NhZ2UuaW5kZXhPZignZG9lcyBub3QgZXhpc3QnKSA+IC0xO1xufVxuXG4vKipcbiAqIFJldHJ5IGFuIGFzeW5jIG9wZXJhdGlvbiB1bnRpbCBhIGRlYWRsaW5lIGlzIGhpdC5cbiAqXG4gKiBVc2UgYHJldHJ5LmZvclNlY29uZHMoKWAgdG8gY29uc3RydWN0IGEgZGVhZGxpbmUgcmVsYXRpdmUgdG8gcmlnaHQgbm93LlxuICpcbiAqIEV4Y2VwdGlvbnMgd2lsbCBjYXVzZSB0aGUgb3BlcmF0aW9uIHRvIHJldHJ5LiBVc2UgYHJldHJ5LmFib3J0YCB0byBhbm5vdGF0ZSBhbiBleGNlcHRpb25cbiAqIHRvIHN0b3AgdGhlIHJldHJ5IGFuZCBlbmQgaW4gYSBmYWlsdXJlLlxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gcmV0cnk8QT4ob3BlcmF0aW9uOiBzdHJpbmcsIGRlYWRsaW5lOiBEYXRlLCBibG9jazogKCkgPT4gUHJvbWlzZTxBPik6IFByb21pc2U8QT4ge1xuICBsZXQgaSA9IDA7XG4gIGxvZyhg8J+SiCAke29wZXJhdGlvbn1gKTtcbiAgd2hpbGUgKHRydWUpIHtcbiAgICB0cnkge1xuICAgICAgaSsrO1xuICAgICAgY29uc3QgcmV0ID0gYXdhaXQgYmxvY2soKTtcbiAgICAgIGxvZyhg8J+SiCAke29wZXJhdGlvbn06IHN1Y2NlZWRlZCBhZnRlciAke2l9IGF0dGVtcHRzYCk7XG4gICAgICByZXR1cm4gcmV0O1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGlmIChlLmFib3J0IHx8IERhdGUubm93KCkgPiBkZWFkbGluZS5nZXRUaW1lKCApKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgJHtvcGVyYXRpb259OiBkaWQgbm90IHN1Y2NlZWQgYWZ0ZXIgJHtpfSBhdHRlbXB0czogJHtlfWApO1xuICAgICAgfVxuICAgICAgbG9nKGDij7MgJHtvcGVyYXRpb259ICgke2UubWVzc2FnZX0pYCk7XG4gICAgICBhd2FpdCBzbGVlcCg1MDAwKTtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBNYWtlIGEgZGVhZGxpbmUgZm9yIHRoZSBgcmV0cnlgIGZ1bmN0aW9uIHJlbGF0aXZlIHRvIHRoZSBjdXJyZW50IHRpbWUuXG4gKi9cbnJldHJ5LmZvclNlY29uZHMgPSAoc2Vjb25kczogbnVtYmVyKTogRGF0ZSA9PiB7XG4gIHJldHVybiBuZXcgRGF0ZShEYXRlLm5vdygpICsgc2Vjb25kcyAqIDEwMDApO1xufTtcblxuLyoqXG4gKiBBbm5vdGF0ZSBhbiBlcnJvciB0byBzdG9wIHRoZSByZXRyeWluZ1xuICovXG5yZXRyeS5hYm9ydCA9IChlOiBFcnJvcik6IEVycm9yID0+IHtcbiAgKGUgYXMgYW55KS5hYm9ydCA9IHRydWU7XG4gIHJldHVybiBlO1xufTtcblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHNsZWVwKG1zOiBudW1iZXIpIHtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKG9rID0+IHNldFRpbWVvdXQob2ssIG1zKSk7XG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBlbXB0eUJ1Y2tldChidWNrZXROYW1lOiBzdHJpbmcpIHtcbiAgY29uc3Qgb2JqZWN0cyA9IGF3YWl0IHMzKCdsaXN0T2JqZWN0cycsIHsgQnVja2V0OiBidWNrZXROYW1lIH0pO1xuICBjb25zdCBkZWxldGVzID0gKG9iamVjdHMuQ29udGVudHMgfHwgW10pLm1hcChvYmogPT4gb2JqLktleSB8fCAnJykuZmlsdGVyKGQgPT4gISFkKTtcbiAgaWYgKGRlbGV0ZXMubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICB9XG4gIHJldHVybiBzMygnZGVsZXRlT2JqZWN0cycsIHtcbiAgICBCdWNrZXQ6IGJ1Y2tldE5hbWUsXG4gICAgRGVsZXRlOiB7XG4gICAgICBPYmplY3RzOiBkZWxldGVzLm1hcChkID0+ICh7IEtleTogZCB9KSksXG4gICAgICBRdWlldDogZmFsc2UsXG4gICAgfSxcbiAgfSk7XG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBkZWxldGVJbWFnZVJlcG9zaXRvcnkocmVwb3NpdG9yeU5hbWU6IHN0cmluZykge1xuICBhd2FpdCBlY3IoJ2RlbGV0ZVJlcG9zaXRvcnknLCB7IHJlcG9zaXRvcnlOYW1lLCBmb3JjZTogdHJ1ZSB9KTtcbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGRlbGV0ZUJ1Y2tldChidWNrZXROYW1lOiBzdHJpbmcpIHtcbiAgdHJ5IHtcbiAgICBhd2FpdCBlbXB0eUJ1Y2tldChidWNrZXROYW1lKTtcbiAgICBhd2FpdCBzMygnZGVsZXRlQnVja2V0Jywge1xuICAgICAgQnVja2V0OiBidWNrZXROYW1lLFxuICAgIH0pO1xuICB9IGNhdGNoIChlKSB7XG4gICAgaWYgKGlzQnVja2V0TWlzc2luZ0Vycm9yKGUpKSB7IHJldHVybjsgfVxuICAgIHRocm93IGU7XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIG91dHB1dEZyb21TdGFjayhrZXk6IHN0cmluZywgc3RhY2s6IEFXUy5DbG91ZEZvcm1hdGlvbi5TdGFjayk6IHN0cmluZyB8IHVuZGVmaW5lZCB7XG4gIHJldHVybiAoc3RhY2suT3V0cHV0cyA/PyBbXSkuZmluZChvID0+IG8uT3V0cHV0S2V5ID09PSBrZXkpPy5PdXRwdXRWYWx1ZTtcbn1cbiJdfQ==