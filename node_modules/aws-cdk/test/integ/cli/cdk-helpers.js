"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.rememberToDeleteBucket = exports.shell = exports.cleanup = exports.deleteableStacks = exports.prepareAppFixture = exports.cloneDirectory = exports.fullStackName = exports.cdk = exports.cdkDestroy = exports.cdkDeploy = exports.log = exports.STACK_NAME_PREFIX = exports.INTEG_TEST_DIR = void 0;
const child_process = require("child_process");
const os = require("os");
const path = require("path");
const aws_helpers_1 = require("./aws-helpers");
const corking_1 = require("./corking");
exports.INTEG_TEST_DIR = path.join(os.tmpdir(), 'cdk-integ-test2');
// create a unique stack name prefix for this test test run. this is passed
// through an environment variable to app.js so that all stacks use this prefix.
const timestamp = new Date().toISOString().replace(/[^0-9]/g, '');
exports.STACK_NAME_PREFIX = `cdktest-${timestamp}`;
process.stdout.write('~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n');
process.stdout.write(` All stacks created by this test run will have the prefix: ${exports.STACK_NAME_PREFIX}\n`);
process.stdout.write('~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n');
function log(x) {
    process.stderr.write(x + '\n');
}
exports.log = log;
async function cdkDeploy(stackNames, options = {}) {
    var _a, _b;
    stackNames = typeof stackNames === 'string' ? [stackNames] : stackNames;
    const neverRequireApproval = (_a = options.neverRequireApproval) !== null && _a !== void 0 ? _a : true;
    return await cdk(['deploy',
        ...(neverRequireApproval ? ['--require-approval=never'] : []), // Default to no approval in an unattended test
        ...((_b = options.options) !== null && _b !== void 0 ? _b : []), ...fullStackName(stackNames)], options);
}
exports.cdkDeploy = cdkDeploy;
async function cdkDestroy(stackNames, options = {}) {
    var _a;
    stackNames = typeof stackNames === 'string' ? [stackNames] : stackNames;
    return await cdk(['destroy',
        '-f', // We never want a prompt in an unattended test
        ...((_a = options.options) !== null && _a !== void 0 ? _a : []), ...fullStackName(stackNames)], options);
}
exports.cdkDestroy = cdkDestroy;
async function cdk(args, options = {}) {
    return await shell(['cdk', ...args], {
        cwd: exports.INTEG_TEST_DIR,
        ...options,
        modEnv: {
            AWS_REGION: (await aws_helpers_1.testEnv()).region,
            AWS_DEFAULT_REGION: (await aws_helpers_1.testEnv()).region,
            STACK_NAME_PREFIX: exports.STACK_NAME_PREFIX,
            ...options.modEnv,
        },
    });
}
exports.cdk = cdk;
function fullStackName(stackNames) {
    if (typeof stackNames === 'string') {
        return `${exports.STACK_NAME_PREFIX}-${stackNames}`;
    }
    else {
        return stackNames.map(s => `${exports.STACK_NAME_PREFIX}-${s}`);
    }
}
exports.fullStackName = fullStackName;
/**
 * Prepare a target dir byreplicating a source directory
 */
async function cloneDirectory(source, target) {
    await shell(['rm', '-rf', target]);
    await shell(['mkdir', '-p', target]);
    await shell(['cp', '-R', source + '/*', target]);
}
exports.cloneDirectory = cloneDirectory;
/**
 * Prepare the app fixture
 *
 * If this is done in the main test script, it will be skipped
 * in the subprocess scripts since the app fixture can just be reused.
 */
async function prepareAppFixture() {
    await cloneDirectory(path.join(__dirname, 'app'), exports.INTEG_TEST_DIR);
    await shell(['npm', 'install',
        '@aws-cdk/core',
        '@aws-cdk/aws-sns',
        '@aws-cdk/aws-iam',
        '@aws-cdk/aws-lambda',
        '@aws-cdk/aws-ssm',
        '@aws-cdk/aws-ecr-assets',
        '@aws-cdk/aws-cloudformation',
        '@aws-cdk/aws-ec2'], {
        cwd: exports.INTEG_TEST_DIR,
    });
}
exports.prepareAppFixture = prepareAppFixture;
/**
 * Return the stacks starting with our testing prefix that should be deleted
 */
async function deleteableStacks(prefix) {
    var _a;
    const statusFilter = [
        'CREATE_IN_PROGRESS', 'CREATE_FAILED', 'CREATE_COMPLETE',
        'ROLLBACK_IN_PROGRESS', 'ROLLBACK_FAILED', 'ROLLBACK_COMPLETE',
        'DELETE_FAILED',
        'UPDATE_IN_PROGRESS', 'UPDATE_COMPLETE_CLEANUP_IN_PROGRESS',
        'UPDATE_COMPLETE', 'UPDATE_ROLLBACK_IN_PROGRESS',
        'UPDATE_ROLLBACK_FAILED',
        'UPDATE_ROLLBACK_COMPLETE_CLEANUP_IN_PROGRESS',
        'UPDATE_ROLLBACK_COMPLETE', 'REVIEW_IN_PROGRESS',
        'IMPORT_IN_PROGRESS', 'IMPORT_COMPLETE',
        'IMPORT_ROLLBACK_IN_PROGRESS', 'IMPORT_ROLLBACK_FAILED',
        'IMPORT_ROLLBACK_COMPLETE',
    ];
    const response = await aws_helpers_1.cloudFormation('describeStacks', {});
    return ((_a = response.Stacks) !== null && _a !== void 0 ? _a : [])
        .filter(s => s.StackName.startsWith(prefix))
        .filter(s => statusFilter.includes(s.StackStatus))
        .filter(s => s.RootId === undefined); // Only delete parent stacks. Nested stacks are deleted in the process
}
exports.deleteableStacks = deleteableStacks;
/**
 * Cleanup leftover stacks and buckets
 */
async function cleanup() {
    const stacksToDelete = await deleteableStacks(exports.STACK_NAME_PREFIX);
    // Bootstrap stacks have buckets that need to be cleaned
    const bucketNames = stacksToDelete.map(stack => aws_helpers_1.outputFromStack('BucketName', stack)).filter(defined);
    await Promise.all(bucketNames.map(aws_helpers_1.emptyBucket));
    // Bootstrap stacks have ECR repositories with images which should be deleted
    const imageRepositoryNames = stacksToDelete.map(stack => aws_helpers_1.outputFromStack('ImageRepositoryName', stack)).filter(defined);
    await Promise.all(imageRepositoryNames.map(aws_helpers_1.deleteImageRepository));
    await aws_helpers_1.deleteStacks(...stacksToDelete.map(s => s.StackName));
    // We might have leaked some buckets by upgrading the bootstrap stack. Be
    // sure to clean everything.
    for (const bucket of bucketsToDelete) {
        await aws_helpers_1.deleteBucket(bucket);
    }
    bucketsToDelete = [];
}
exports.cleanup = cleanup;
/**
 * A shell command that does what you want
 *
 * Is platform-aware, handles errors nicely.
 */
async function shell(command, options = {}) {
    var _a;
    if (options.modEnv && options.env) {
        throw new Error('Use either env or modEnv but not both');
    }
    log(`ðŸ’» ${command.join(' ')}`);
    const env = (_a = options.env) !== null && _a !== void 0 ? _a : (options.modEnv ? { ...process.env, ...options.modEnv } : undefined);
    const child = child_process.spawn(command[0], command.slice(1), {
        ...options,
        env,
        // Need this for Windows where we want .cmd and .bat to be found as well.
        shell: true,
        stdio: ['ignore', 'pipe', 'pipe'],
    });
    return new Promise((resolve, reject) => {
        const stdout = new Array();
        const stderr = new Array();
        child.stdout.on('data', chunk => {
            corking_1.writeOutput('stdout', chunk);
            stdout.push(chunk);
        });
        child.stderr.on('data', chunk => {
            var _a;
            corking_1.writeOutput('stderr', chunk);
            if ((_a = options.captureStderr) !== null && _a !== void 0 ? _a : true) {
                stderr.push(chunk);
            }
        });
        child.once('error', reject);
        child.once('close', code => {
            if (code === 0 || options.allowErrExit) {
                resolve((Buffer.concat(stdout).toString('utf-8') + Buffer.concat(stderr).toString('utf-8')).trim());
            }
            else {
                reject(new Error(`'${command.join(' ')}' exited with error code ${code}: ${Buffer.concat(stderr).toString('utf-8').trim()}`));
            }
        });
    });
}
exports.shell = shell;
let bucketsToDelete = new Array();
/**
 * Append this to the list of buckets to potentially delete
 *
 * At the end of a test, we clean up buckets that may not have gotten destroyed
 * (for whatever reason).
 */
function rememberToDeleteBucket(bucketName) {
    bucketsToDelete.push(bucketName);
}
exports.rememberToDeleteBucket = rememberToDeleteBucket;
function defined(x) {
    return x !== undefined;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY2RrLWhlbHBlcnMuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJjZGstaGVscGVycy50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7QUFBQSwrQ0FBK0M7QUFDL0MseUJBQXlCO0FBQ3pCLDZCQUE2QjtBQUM3QiwrQ0FBeUk7QUFDekksdUNBQXdDO0FBRTNCLFFBQUEsY0FBYyxHQUFHLElBQUksQ0FBQyxJQUFJLENBQUMsRUFBRSxDQUFDLE1BQU0sRUFBRSxFQUFFLGlCQUFpQixDQUFDLENBQUM7QUFFeEUsMkVBQTJFO0FBQzNFLGdGQUFnRjtBQUNoRixNQUFNLFNBQVMsR0FBRyxJQUFJLElBQUksRUFBRSxDQUFDLFdBQVcsRUFBRSxDQUFDLE9BQU8sQ0FBQyxTQUFTLEVBQUUsRUFBRSxDQUFDLENBQUM7QUFDckQsUUFBQSxpQkFBaUIsR0FBRyxXQUFXLFNBQVMsRUFBRSxDQUFDO0FBRXhELE9BQU8sQ0FBQyxNQUFNLENBQUMsS0FBSyxDQUFDLHlHQUF5RyxDQUFDLENBQUM7QUFDaEksT0FBTyxDQUFDLE1BQU0sQ0FBQyxLQUFLLENBQUMsOERBQThELHlCQUFpQixJQUFJLENBQUMsQ0FBQztBQUMxRyxPQUFPLENBQUMsTUFBTSxDQUFDLEtBQUssQ0FBQyx5R0FBeUcsQ0FBQyxDQUFDO0FBNEJoSSxTQUFnQixHQUFHLENBQUMsQ0FBUztJQUMzQixPQUFPLENBQUMsTUFBTSxDQUFDLEtBQUssQ0FBQyxDQUFDLEdBQUcsSUFBSSxDQUFDLENBQUM7QUFDakMsQ0FBQztBQUZELGtCQUVDO0FBRU0sS0FBSyxVQUFVLFNBQVMsQ0FBQyxVQUE2QixFQUFFLFVBQXlCLEVBQUU7O0lBQ3hGLFVBQVUsR0FBRyxPQUFPLFVBQVUsS0FBSyxRQUFRLENBQUMsQ0FBQyxDQUFDLENBQUMsVUFBVSxDQUFDLENBQUMsQ0FBQyxDQUFDLFVBQVUsQ0FBQztJQUV4RSxNQUFNLG9CQUFvQixTQUFHLE9BQU8sQ0FBQyxvQkFBb0IsbUNBQUksSUFBSSxDQUFDO0lBRWxFLE9B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QUMsSUFBSSxPQUFPLENBQUMsWUFBWSxFQUFFO2dCQUN0QyxPQUFPLENBQUMsQ0FBQyxNQUFNLENBQUMsTUFBTSxDQUFDLE1BQU0sQ0FBQyxDQUFDLFFBQVEsQ0FBQyxPQUFPLENBQUMsR0FBRyxNQUFNLENBQUMsTUFBTSxDQUFDLE1BQU0sQ0FBQyxDQUFDLFFBQVEsQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDLElBQUksRUFBRSxDQUFDLENBQUM7YUFDckc7aUJBQU07Z0JBQ0wsTUFBTSxDQUFDLElBQUksS0FBSyxDQUFDLElBQUksT0FBTyxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsNEJBQTRCLElBQUksS0FBSyxNQUFNLENBQUMsTUFBTSxDQUFDLE1BQU0sQ0FBQyxDQUFDLFFBQVEsQ0FBQyxPQUFPLENBQUMsQ0FBQyxJQUFJLEVBQUUsRUFBRSxDQUFDLENBQUMsQ0FBQzthQUMvSDtRQUNILENBQUMsQ0FBQyxDQUFDO0lBQ0wsQ0FBQyxDQUFDLENBQUM7QUFDTCxDQUFDO0FBM0NELHNCQTJDQztBQUVELElBQUksZUFBZSxHQUFHLElBQUksS0FBSyxFQUFVLENBQUM7QUFFMUM7Ozs7O0dBS0c7QUFDSCxTQUFnQixzQkFBc0IsQ0FBQyxVQUFrQjtJQUN2RCxlQUFlLENBQUMsSUFBSSxDQUFDLFVBQVUsQ0FBQyxDQUFDO0FBQ25DLENBQUM7QUFGRCx3REFFQztBQUVELFNBQVMsT0FBTyxDQUFJLENBQUk7SUFDdEIsT0FBTyxDQUFDLEtBQUssU0FBUyxDQUFDO0FBQ3pCLENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgKiBhcyBjaGlsZF9wcm9jZXNzIGZyb20gJ2NoaWxkX3Byb2Nlc3MnO1xuaW1wb3J0ICogYXMgb3MgZnJvbSAnb3MnO1xuaW1wb3J0ICogYXMgcGF0aCBmcm9tICdwYXRoJztcbmltcG9ydCB7IGNsb3VkRm9ybWF0aW9uLCBkZWxldGVCdWNrZXQsIGRlbGV0ZUltYWdlUmVwb3NpdG9yeSwgZGVsZXRlU3RhY2tzLCBlbXB0eUJ1Y2tldCwgb3V0cHV0RnJvbVN0YWNrLCB0ZXN0RW52IH0gZnJvbSAnLi9hd3MtaGVscGVycyc7XG5pbXBvcnQgeyB3cml0ZU91dHB1dCB9IGZyb20gJy4vY29ya2luZyc7XG5cbmV4cG9ydCBjb25zdCBJTlRFR19URVNUX0RJUiA9IHBhdGguam9pbihvcy50bXBkaXIoKSwgJ2Nkay1pbnRlZy10ZXN0MicpO1xuXG4vLyBjcmVhdGUgYSB1bmlxdWUgc3RhY2sgbmFtZSBwcmVmaXggZm9yIHRoaXMgdGVzdCB0ZXN0IHJ1bi4gdGhpcyBpcyBwYXNzZWRcbi8vIHRocm91Z2ggYW4gZW52aXJvbm1lbnQgdmFyaWFibGUgdG8gYXBwLmpzIHNvIHRoYXQgYWxsIHN0YWNrcyB1c2UgdGhpcyBwcmVmaXguXG5jb25zdCB0aW1lc3RhbXAgPSBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCkucmVwbGFjZSgvW14wLTldL2csICcnKTtcbmV4cG9ydCBjb25zdCBTVEFDS19OQU1FX1BSRUZJWCA9IGBjZGt0ZXN0LSR7dGltZXN0YW1wfWA7XG5cbnByb2Nlc3Muc3Rkb3V0LndyaXRlKCd+fn5+fn5+fn5+fn5+fn5+fn5+fn5+fn5+fn5+fn5+fn5+fn5+fn5+fn5+fn5+fn5+fn5+fn5+fn5+fn5+fn5+fn5+fn5+fn5+fn5+fn5+fn5+fn5+fn5+fn5+fn5+fn5+fn5+flxcbicpO1xucHJvY2Vzcy5zdGRvdXQud3JpdGUoYCBBbGwgc3RhY2tzIGNyZWF0ZWQgYnkgdGhpcyB0ZXN0IHJ1biB3aWxsIGhhdmUgdGhlIHByZWZpeDogJHtTVEFDS19OQU1FX1BSRUZJWH1cXG5gKTtcbnByb2Nlc3Muc3Rkb3V0LndyaXRlKCd+fn5+fn5+fn5+fn5+fn5+fn5+fn5+fn5+fn5+fn5+fn5+fn5+fn5+fn5+fn5+fn5+fn5+fn5+fn5+fn5+fn5+fn5+fn5+fn5+fn5+fn5+fn5+fn5+fn5+fn5+fn5+fn5+fn5+flxcbicpO1xuXG5leHBvcnQgaW50ZXJmYWNlIFNoZWxsT3B0aW9ucyBleHRlbmRzIGNoaWxkX3Byb2Nlc3MuU3Bhd25PcHRpb25zIHtcbiAgLyoqXG4gICAqIFByb3BlcnRpZXMgdG8gYWRkIHRvICdlbnYnXG4gICAqL1xuICBtb2RFbnY/OiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+O1xuXG4gIC8qKlxuICAgKiBEb24ndCBmYWlsIHdoZW4gZXhpdGluZyB3aXRoIGFuIGVycm9yXG4gICAqXG4gICAqIEBkZWZhdWx0IGZhbHNlXG4gICAqL1xuICBhbGxvd0VyckV4aXQ/OiBib29sZWFuO1xuXG4gIC8qKlxuICAgKiBXaGV0aGVyIHRvIGNhcHR1cmUgc3RkZXJyXG4gICAqXG4gICAqIEBkZWZhdWx0IHRydWVcbiAgICovXG4gIGNhcHR1cmVTdGRlcnI/OiBib29sZWFuO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIENka0NsaU9wdGlvbnMgZXh0ZW5kcyBTaGVsbE9wdGlvbnMge1xuICBvcHRpb25zPzogc3RyaW5nW107XG4gIG5ldmVyUmVxdWlyZUFwcHJvdmFsPzogYm9vbGVhbjtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGxvZyh4OiBzdHJpbmcpIHtcbiAgcHJvY2Vzcy5zdGRlcnIud3JpdGUoeCArICdcXG4nKTtcbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGNka0RlcGxveShzdGFja05hbWVzOiBzdHJpbmcgfCBzdHJpbmdbXSwgb3B0aW9uczogQ2RrQ2xpT3B0aW9ucyA9IHt9KSB7XG4gIHN0YWNrTmFtZXMgPSB0eXBlb2Ygc3RhY2tOYW1lcyA9PT0gJ3N0cmluZycgPyBbc3RhY2tOYW1lc10gOiBzdGFja05hbWVzO1xuXG4gIGNvbnN0IG5ldmVyUmVxdWlyZUFwcHJvdmFsID0gb3B0aW9ucy5uZXZlclJlcXVpcmVBcHByb3ZhbCA/PyB0cnVlO1xuXG4gIHJldHVybiBhd2FpdCBjZGsoWydkZXBsb3knLFxuICAgIC4uLihuZXZlclJlcXVpcmVBcHByb3ZhbCA/IFsnLS1yZXF1aXJlLWFwcHJvdmFsPW5ldmVyJ10gOiBbXSksIC8vIERlZmF1bHQgdG8gbm8gYXBwcm92YWwgaW4gYW4gdW5hdHRlbmRlZCB0ZXN0XG4gICAgLi4uKG9wdGlvbnMub3B0aW9ucyA/PyBbXSksXG4gICAgLi4uZnVsbFN0YWNrTmFtZShzdGFja05hbWVzKV0sIG9wdGlvbnMpO1xufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gY2RrRGVzdHJveShzdGFja05hbWVzOiBzdHJpbmcgfCBzdHJpbmdbXSwgb3B0aW9uczogQ2RrQ2xpT3B0aW9ucyA9IHt9KSB7XG4gIHN0YWNrTmFtZXMgPSB0eXBlb2Ygc3RhY2tOYW1lcyA9PT0gJ3N0cmluZycgPyBbc3RhY2tOYW1lc10gOiBzdGFja05hbWVzO1xuXG4gIHJldHVybiBhd2FpdCBjZGsoWydkZXN0cm95JyxcbiAgICAnLWYnLCAvLyBXZSBuZXZlciB3YW50IGEgcHJvbXB0IGluIGFuIHVuYXR0ZW5kZWQgdGVzdFxuICAgIC4uLihvcHRpb25zLm9wdGlvbnMgPz8gW10pLFxuICAgIC4uLmZ1bGxTdGFja05hbWUoc3RhY2tOYW1lcyldLCBvcHRpb25zKTtcbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGNkayhhcmdzOiBzdHJpbmdbXSwgb3B0aW9uczogQ2RrQ2xpT3B0aW9ucyA9IHt9KSB7XG4gIHJldHVybiBhd2FpdCBzaGVsbChbJ2NkaycsIC4uLmFyZ3NdLCB7XG4gICAgY3dkOiBJTlRFR19URVNUX0RJUixcbiAgICAuLi5vcHRpb25zLFxuICAgIG1vZEVudjoge1xuICAgICAgQVdTX1JFR0lPTjogKGF3YWl0IHRlc3RFbnYoKSkucmVnaW9uLFxuICAgICAgQVdTX0RFRkFVTFRfUkVHSU9OOiAoYXdhaXQgdGVzdEVudigpKS5yZWdpb24sXG4gICAgICBTVEFDS19OQU1FX1BSRUZJWCxcbiAgICAgIC4uLm9wdGlvbnMubW9kRW52LFxuICAgIH0sXG4gIH0pO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZnVsbFN0YWNrTmFtZShzdGFja05hbWU6IHN0cmluZyk6IHN0cmluZztcbmV4cG9ydCBmdW5jdGlvbiBmdWxsU3RhY2tOYW1lKHN0YWNrTmFtZXM6IHN0cmluZ1tdKTogc3RyaW5nW107XG5leHBvcnQgZnVuY3Rpb24gZnVsbFN0YWNrTmFtZShzdGFja05hbWVzOiBzdHJpbmcgfCBzdHJpbmdbXSk6IHN0cmluZyB8IHN0cmluZ1tdIHtcbiAgaWYgKHR5cGVvZiBzdGFja05hbWVzID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBgJHtTVEFDS19OQU1FX1BSRUZJWH0tJHtzdGFja05hbWVzfWA7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHN0YWNrTmFtZXMubWFwKHMgPT4gYCR7U1RBQ0tfTkFNRV9QUkVGSVh9LSR7c31gKTtcbiAgfVxufVxuXG4vKipcbiAqIFByZXBhcmUgYSB0YXJnZXQgZGlyIGJ5cmVwbGljYXRpbmcgYSBzb3VyY2UgZGlyZWN0b3J5XG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBjbG9uZURpcmVjdG9yeShzb3VyY2U6IHN0cmluZywgdGFyZ2V0OiBzdHJpbmcpIHtcbiAgYXdhaXQgc2hlbGwoWydybScsICctcmYnLCB0YXJnZXRdKTtcbiAgYXdhaXQgc2hlbGwoWydta2RpcicsICctcCcsIHRhcmdldF0pO1xuICBhd2FpdCBzaGVsbChbJ2NwJywgJy1SJywgc291cmNlICsgJy8qJywgdGFyZ2V0XSk7XG59XG5cbi8qKlxuICogUHJlcGFyZSB0aGUgYXBwIGZpeHR1cmVcbiAqXG4gKiBJZiB0aGlzIGlzIGRvbmUgaW4gdGhlIG1haW4gdGVzdCBzY3JpcHQsIGl0IHdpbGwgYmUgc2tpcHBlZFxuICogaW4gdGhlIHN1YnByb2Nlc3Mgc2NyaXB0cyBzaW5jZSB0aGUgYXBwIGZpeHR1cmUgY2FuIGp1c3QgYmUgcmV1c2VkLlxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gcHJlcGFyZUFwcEZpeHR1cmUoKSB7XG4gIGF3YWl0IGNsb25lRGlyZWN0b3J5KHBhdGguam9pbihfX2Rpcm5hbWUsICdhcHAnKSwgSU5URUdfVEVTVF9ESVIpO1xuXG4gIGF3YWl0IHNoZWxsKFsnbnBtJywgJ2luc3RhbGwnLFxuICAgICdAYXdzLWNkay9jb3JlJyxcbiAgICAnQGF3cy1jZGsvYXdzLXNucycsXG4gICAgJ0Bhd3MtY2RrL2F3cy1pYW0nLFxuICAgICdAYXdzLWNkay9hd3MtbGFtYmRhJyxcbiAgICAnQGF3cy1jZGsvYXdzLXNzbScsXG4gICAgJ0Bhd3MtY2RrL2F3cy1lY3ItYXNzZXRzJyxcbiAgICAnQGF3cy1jZGsvYXdzLWNsb3VkZm9ybWF0aW9uJyxcbiAgICAnQGF3cy1jZGsvYXdzLWVjMiddLCB7XG4gICAgY3dkOiBJTlRFR19URVNUX0RJUixcbiAgfSk7XG59XG5cbi8qKlxuICogUmV0dXJuIHRoZSBzdGFja3Mgc3RhcnRpbmcgd2l0aCBvdXIgdGVzdGluZyBwcmVmaXggdGhhdCBzaG91bGQgYmUgZGVsZXRlZFxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZGVsZXRlYWJsZVN0YWNrcyhwcmVmaXg6IHN0cmluZyk6IFByb21pc2U8QVdTLkNsb3VkRm9ybWF0aW9uLlN0YWNrW10+IHtcbiAgY29uc3Qgc3RhdHVzRmlsdGVyID0gW1xuICAgICdDUkVBVEVfSU5fUFJPR1JFU1MnLCAnQ1JFQVRFX0ZBSUxFRCcsICdDUkVBVEVfQ09NUExFVEUnLFxuICAgICdST0xMQkFDS19JTl9QUk9HUkVTUycsICdST0xMQkFDS19GQUlMRUQnLCAnUk9MTEJBQ0tfQ09NUExFVEUnLFxuICAgICdERUxFVEVfRkFJTEVEJyxcbiAgICAnVVBEQVRFX0lOX1BST0dSRVNTJywgJ1VQREFURV9DT01QTEVURV9DTEVBTlVQX0lOX1BST0dSRVNTJyxcbiAgICAnVVBEQVRFX0NPTVBMRVRFJywgJ1VQREFURV9ST0xMQkFDS19JTl9QUk9HUkVTUycsXG4gICAgJ1VQREFURV9ST0xMQkFDS19GQUlMRUQnLFxuICAgICdVUERBVEVfUk9MTEJBQ0tfQ09NUExFVEVfQ0xFQU5VUF9JTl9QUk9HUkVTUycsXG4gICAgJ1VQREFURV9ST0xMQkFDS19DT01QTEVURScsICdSRVZJRVdfSU5fUFJPR1JFU1MnLFxuICAgICdJTVBPUlRfSU5fUFJPR1JFU1MnLCAnSU1QT1JUX0NPTVBMRVRFJyxcbiAgICAnSU1QT1JUX1JPTExCQUNLX0lOX1BST0dSRVNTJywgJ0lNUE9SVF9ST0xMQkFDS19GQUlMRUQnLFxuICAgICdJTVBPUlRfUk9MTEJBQ0tfQ09NUExFVEUnLFxuICBdO1xuXG4gIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgY2xvdWRGb3JtYXRpb24oJ2Rlc2NyaWJlU3RhY2tzJywge30pO1xuXG4gIHJldHVybiAocmVzcG9uc2UuU3RhY2tzID8/IFtdKVxuICAgIC5maWx0ZXIocyA9PiBzLlN0YWNrTmFtZS5zdGFydHNXaXRoKHByZWZpeCkpXG4gICAgLmZpbHRlcihzID0+IHN0YXR1c0ZpbHRlci5pbmNsdWRlcyhzLlN0YWNrU3RhdHVzKSlcbiAgICAuZmlsdGVyKHMgPT4gcy5Sb290SWQgPT09IHVuZGVmaW5lZCk7IC8vIE9ubHkgZGVsZXRlIHBhcmVudCBzdGFja3MuIE5lc3RlZCBzdGFja3MgYXJlIGRlbGV0ZWQgaW4gdGhlIHByb2Nlc3Ncbn1cblxuLyoqXG4gKiBDbGVhbnVwIGxlZnRvdmVyIHN0YWNrcyBhbmQgYnVja2V0c1xuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gY2xlYW51cCgpOiBQcm9taXNlPHZvaWQ+IHtcbiAgY29uc3Qgc3RhY2tzVG9EZWxldGUgPSBhd2FpdCBkZWxldGVhYmxlU3RhY2tzKFNUQUNLX05BTUVfUFJFRklYKTtcblxuICAvLyBCb290c3RyYXAgc3RhY2tzIGhhdmUgYnVja2V0cyB0aGF0IG5lZWQgdG8gYmUgY2xlYW5lZFxuICBjb25zdCBidWNrZXROYW1lcyA9IHN0YWNrc1RvRGVsZXRlLm1hcChzdGFjayA9PiBvdXRwdXRGcm9tU3RhY2soJ0J1Y2tldE5hbWUnLCBzdGFjaykpLmZpbHRlcihkZWZpbmVkKTtcbiAgYXdhaXQgUHJvbWlzZS5hbGwoYnVja2V0TmFtZXMubWFwKGVtcHR5QnVja2V0KSk7XG5cbiAgLy8gQm9vdHN0cmFwIHN0YWNrcyBoYXZlIEVDUiByZXBvc2l0b3JpZXMgd2l0aCBpbWFnZXMgd2hpY2ggc2hvdWxkIGJlIGRlbGV0ZWRcbiAgY29uc3QgaW1hZ2VSZXBvc2l0b3J5TmFtZXMgPSBzdGFja3NUb0RlbGV0ZS5tYXAoc3RhY2sgPT4gb3V0cHV0RnJvbVN0YWNrKCdJbWFnZVJlcG9zaXRvcnlOYW1lJywgc3RhY2spKS5maWx0ZXIoZGVmaW5lZCk7XG4gIGF3YWl0IFByb21pc2UuYWxsKGltYWdlUmVwb3NpdG9yeU5hbWVzLm1hcChkZWxldGVJbWFnZVJlcG9zaXRvcnkpKTtcblxuICBhd2FpdCBkZWxldGVTdGFja3MoLi4uc3RhY2tzVG9EZWxldGUubWFwKHMgPT4gcy5TdGFja05hbWUpKTtcblxuICAvLyBXZSBtaWdodCBoYXZlIGxlYWtlZCBzb21lIGJ1Y2tldHMgYnkgdXBncmFkaW5nIHRoZSBib290c3RyYXAgc3RhY2suIEJlXG4gIC8vIHN1cmUgdG8gY2xlYW4gZXZlcnl0aGluZy5cbiAgZm9yIChjb25zdCBidWNrZXQgb2YgYnVja2V0c1RvRGVsZXRlKSB7XG4gICAgYXdhaXQgZGVsZXRlQnVja2V0KGJ1Y2tldCk7XG4gIH1cbiAgYnVja2V0c1RvRGVsZXRlID0gW107XG59XG5cbi8qKlxuICogQSBzaGVsbCBjb21tYW5kIHRoYXQgZG9lcyB3aGF0IHlvdSB3YW50XG4gKlxuICogSXMgcGxhdGZvcm0tYXdhcmUsIGhhbmRsZXMgZXJyb3JzIG5pY2VseS5cbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHNoZWxsKGNvbW1hbmQ6IHN0cmluZ1tdLCBvcHRpb25zOiBTaGVsbE9wdGlvbnMgPSB7fSk6IFByb21pc2U8c3RyaW5nPiB7XG4gIGlmIChvcHRpb25zLm1vZEVudiAmJiBvcHRpb25zLmVudikge1xuICAgIHRocm93IG5ldyBFcnJvcignVXNlIGVpdGhlciBlbnYgb3IgbW9kRW52IGJ1dCBub3QgYm90aCcpO1xuICB9XG5cbiAgbG9nKGDwn5K7ICR7Y29tbWFuZC5qb2luKCcgJyl9YCk7XG5cbiAgY29uc3QgZW52ID0gb3B0aW9ucy5lbnYgPz8gKG9wdGlvbnMubW9kRW52ID8geyAuLi5wcm9jZXNzLmVudiwgLi4ub3B0aW9ucy5tb2RFbnYgfSA6IHVuZGVmaW5lZCk7XG5cbiAgY29uc3QgY2hpbGQgPSBjaGlsZF9wcm9jZXNzLnNwYXduKGNvbW1hbmRbMF0sIGNvbW1hbmQuc2xpY2UoMSksIHtcbiAgICAuLi5vcHRpb25zLFxuICAgIGVudixcbiAgICAvLyBOZWVkIHRoaXMgZm9yIFdpbmRvd3Mgd2hlcmUgd2Ugd2FudCAuY21kIGFuZCAuYmF0IHRvIGJlIGZvdW5kIGFzIHdlbGwuXG4gICAgc2hlbGw6IHRydWUsXG4gICAgc3RkaW86IFsnaWdub3JlJywgJ3BpcGUnLCAncGlwZSddLFxuICB9KTtcblxuICByZXR1cm4gbmV3IFByb21pc2U8c3RyaW5nPigocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgY29uc3Qgc3Rkb3V0ID0gbmV3IEFycmF5PEJ1ZmZlcj4oKTtcbiAgICBjb25zdCBzdGRlcnIgPSBuZXcgQXJyYXk8QnVmZmVyPigpO1xuXG4gICAgY2hpbGQuc3Rkb3V0IS5vbignZGF0YScsIGNodW5rID0+IHtcbiAgICAgIHdyaXRlT3V0cHV0KCdzdGRvdXQnLCBjaHVuayk7XG4gICAgICBzdGRvdXQucHVzaChjaHVuayk7XG4gICAgfSk7XG5cbiAgICBjaGlsZC5zdGRlcnIhLm9uKCdkYXRhJywgY2h1bmsgPT4ge1xuICAgICAgd3JpdGVPdXRwdXQoJ3N0ZGVycicsIGNodW5rKTtcbiAgICAgIGlmIChvcHRpb25zLmNhcHR1cmVTdGRlcnIgPz8gdHJ1ZSkge1xuICAgICAgICBzdGRlcnIucHVzaChjaHVuayk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBjaGlsZC5vbmNlKCdlcnJvcicsIHJlamVjdCk7XG5cbiAgICBjaGlsZC5vbmNlKCdjbG9zZScsIGNvZGUgPT4ge1xuICAgICAgaWYgKGNvZGUgPT09IDAgfHwgb3B0aW9ucy5hbGxvd0VyckV4aXQpIHtcbiAgICAgICAgcmVzb2x2ZSgoQnVmZmVyLmNvbmNhdChzdGRvdXQpLnRvU3RyaW5nKCd1dGYtOCcpICsgQnVmZmVyLmNvbmNhdChzdGRlcnIpLnRvU3RyaW5nKCd1dGYtOCcpKS50cmltKCkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVqZWN0KG5ldyBFcnJvcihgJyR7Y29tbWFuZC5qb2luKCcgJyl9JyBleGl0ZWQgd2l0aCBlcnJvciBjb2RlICR7Y29kZX06ICR7QnVmZmVyLmNvbmNhdChzdGRlcnIpLnRvU3RyaW5nKCd1dGYtOCcpLnRyaW0oKX1gKSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH0pO1xufVxuXG5sZXQgYnVja2V0c1RvRGVsZXRlID0gbmV3IEFycmF5PHN0cmluZz4oKTtcblxuLyoqXG4gKiBBcHBlbmQgdGhpcyB0byB0aGUgbGlzdCBvZiBidWNrZXRzIHRvIHBvdGVudGlhbGx5IGRlbGV0ZVxuICpcbiAqIEF0IHRoZSBlbmQgb2YgYSB0ZXN0LCB3ZSBjbGVhbiB1cCBidWNrZXRzIHRoYXQgbWF5IG5vdCBoYXZlIGdvdHRlbiBkZXN0cm95ZWRcbiAqIChmb3Igd2hhdGV2ZXIgcmVhc29uKS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJlbWVtYmVyVG9EZWxldGVCdWNrZXQoYnVja2V0TmFtZTogc3RyaW5nKSB7XG4gIGJ1Y2tldHNUb0RlbGV0ZS5wdXNoKGJ1Y2tldE5hbWUpO1xufVxuXG5mdW5jdGlvbiBkZWZpbmVkPEE+KHg6IEEpOiB4IGlzIE5vbk51bGxhYmxlPEE+IHtcbiAgcmV0dXJuIHggIT09IHVuZGVmaW5lZDtcbn0iXX0=