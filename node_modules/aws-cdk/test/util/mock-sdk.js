"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.errorWithCode = exports.mockResolvedEnvironment = exports.mockToolkitInfo = exports.mockBootstrapStack = exports.MockSdk = exports.MockSdkProvider = void 0;
const AWS = require("aws-sdk");
const lib_1 = require("../../lib");
const cloudformation_1 = require("../../lib/api/util/cloudformation");
const FAKE_CREDENTIALS = new AWS.Credentials({ accessKeyId: 'ACCESS', secretAccessKey: 'SECRET', sessionToken: 'TOKEN ' });
const FAKE_CREDENTIAL_CHAIN = new AWS.CredentialProviderChain([
    () => FAKE_CREDENTIALS,
]);
/**
 * An SDK that allows replacing (some of) the clients
 *
 * Its the responsibility of the consumer to replace all calls that
 * actually will be called.
 */
class MockSdkProvider extends lib_1.SdkProvider {
    constructor(options = {}) {
        var _a;
        super(FAKE_CREDENTIAL_CHAIN, 'bermuda-triangle-1337', { customUserAgent: 'aws-cdk/jest' });
        // SDK contains a real SDK, since some test use 'AWS-mock' to replace the underlying
        // AWS calls which a real SDK would do, and some tests use the 'stub' functionality below.
        if ((_a = options.realSdk) !== null && _a !== void 0 ? _a : true) {
            this.sdk = new lib_1.SDK(FAKE_CREDENTIALS, this.defaultRegion, { customUserAgent: 'aws-cdk/jest' });
        }
        else {
            this.sdk = new MockSdk();
        }
    }
    defaultAccount() {
        return Promise.resolve({ accountId: '123456789012', partition: 'aws' });
    }
    forEnvironment() {
        return Promise.resolve(this.sdk);
    }
    /**
     * Replace the CloudFormation client with the given object
     */
    stubCloudFormation(stubs) {
        this.sdk.cloudFormation = jest.fn().mockReturnValue(partialAwsService(stubs));
    }
    /**
     * Replace the ECR client with the given object
     */
    stubEcr(stubs) {
        this.sdk.ecr = jest.fn().mockReturnValue(partialAwsService(stubs));
    }
    /**
     * Replace the S3 client with the given object
     */
    stubS3(stubs) {
        this.sdk.s3 = jest.fn().mockReturnValue(partialAwsService(stubs));
    }
    /**
     * Replace the STS client with the given object
     */
    stubSTS(stubs) {
        this.sdk.sts = jest.fn().mockReturnValue(partialAwsService(stubs));
    }
}
exports.MockSdkProvider = MockSdkProvider;
class MockSdk {
    constructor() {
        this.currentRegion = 'bermuda-triangle-1337';
        this.cloudFormation = jest.fn();
        this.ec2 = jest.fn();
        this.ssm = jest.fn();
        this.s3 = jest.fn();
        this.route53 = jest.fn();
        this.ecr = jest.fn();
    }
    currentAccount() {
        return Promise.resolve({ accountId: '123456789012', partition: 'aws' });
    }
    /**
     * Replace the CloudFormation client with the given object
     */
    stubCloudFormation(stubs) {
        this.cloudFormation.mockReturnValue(partialAwsService(stubs));
    }
    /**
     * Replace the ECR client with the given object
     */
    stubEcr(stubs) {
        this.ecr.mockReturnValue(partialAwsService(stubs));
    }
}
exports.MockSdk = MockSdk;
/**
 * Wrap synchronous fake handlers so that they sort-of function like a real AWS client
 *
 * For example, turns an object like this:
 *
 * ```ts
 * {
 *   someCall(opts: AWS.Service.SomeCallInput): AWS.Service.SomeCallOutput {
 *     return {...whatever...};
 *   }
 * }
 * ```
 *
 * Into an object that in the type system pretends to be an 'AWS.Service'
 * class (even though it really isn't) and can be called like this:
 *
 * ```ts
 * const service = await sdk.someService(...);
 * const response = await service.someCall(...).promise();
 * ```
 *
 * We only implement the narrow subset of the AWS SDK API that the CDK actually
 * uses, and we cheat on the types to make TypeScript happy on the rest of the API.
 *
 * Most important feature of this class is that it will derive the input and output
 * types of the handlers on the input object from the ACTUAL AWS Service class,
 * so that you don't have to declare them.
 */
function partialAwsService(fns) {
    // Super unsafe in here because I don't know how to make TypeScript happy,
    // but at least the outer types make sure everything that happens in here works out.
    const ret = {};
    for (const [key, handler] of Object.entries(fns)) {
        ret[key] = (args) => new FakeAWSResponse(handler(args));
    }
    return ret;
}
/**
 * Fake AWS response.
 *
 * We only ever 'await response.promise()' so that's the only thing we implement here.
 */
class FakeAWSResponse {
    constructor(x) {
        this.x = x;
    }
    promise() {
        return Promise.resolve(this.x);
    }
}
function mockBootstrapStack(sdk, stack) {
    return cloudformation_1.CloudFormationStack.fromStaticInformation((sdk !== null && sdk !== void 0 ? sdk : new MockSdk()).cloudFormation(), 'CDKToolkit', {
        CreationTime: new Date(),
        StackName: 'CDKToolkit',
        StackStatus: 'CREATE_COMPLETE',
        Outputs: [
            { OutputKey: 'BucketName', OutputValue: 'BUCKET_NAME' },
            { OutputKey: 'BucketDomainName', OutputValue: 'BUCKET_ENDPOINT' },
            { OutputKey: 'BootstrapVersion', OutputValue: '1' },
        ],
        ...stack,
    });
}
exports.mockBootstrapStack = mockBootstrapStack;
function mockToolkitInfo(stack) {
    const sdk = new MockSdk();
    return new lib_1.ToolkitInfo(mockBootstrapStack(sdk, stack), sdk);
}
exports.mockToolkitInfo = mockToolkitInfo;
function mockResolvedEnvironment() {
    return {
        account: '123456789',
        region: 'bermuda-triangle-1337',
        name: 'aws://123456789/bermuda-triangle-1337',
    };
}
exports.mockResolvedEnvironment = mockResolvedEnvironment;
function errorWithCode(code, message) {
    const ret = new Error(message);
    ret.code = code;
    return ret;
}
exports.errorWithCode = errorWithCode;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibW9jay1zZGsuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJtb2NrLXNkay50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7QUFDQSwrQkFBK0I7QUFDL0IsbUNBQXlFO0FBQ3pFLHNFQUF3RTtBQUV4RSxNQUFNLGdCQUFnQixHQUFHLElBQUksR0FBRyxDQUFDLFdBQVcsQ0FBQyxFQUFFLFdBQVcsRUFBRSxRQUFRLEVBQUUsZUFBZSxFQUFFLFFBQVEsRUFBRSxZQUFZLEVBQUUsUUFBUSxFQUFFLENBQUMsQ0FBQztBQUUzSCxNQUFNLHFCQUFxQixHQUFHLElBQUksR0FBRyxDQUFDLHVCQUF1QixDQUFDO0lBQzVELEdBQUcsRUFBRSxDQUFDLGdCQUFnQjtDQUN2QixDQUFDLENBQUM7QUFjSDs7Ozs7R0FLRztBQUNILE1BQWEsZUFBZ0IsU0FBUSxpQkFBVztJQUc5QyxZQUFZLFVBQWtDLEVBQUU7O1FBQzlDLEtBQUssQ0FBQyxxQkFBcUIsRUFBRSx1QkFBdUIsRUFBRSxFQUFFLGVBQWUsRUFBRSxjQUFjLEVBQUUsQ0FBQyxDQUFDO1FBRTNGLG9GQUFvRjtRQUNwRiwwRkFBMEY7UUFDMUYsVUFBSSxPQUFPLENBQUMsT0FBTyxtQ0FBSSxJQUFJLEVBQUU7WUFDM0IsSUFBSSxDQUFDLEdBQUcsR0FBRyxJQUFJLFNBQUcsQ0FBQyxnQkFBZ0IsRUFBRSxJQUFJLENBQUMsYUFBYSxFQUFFLEVBQUUsZUFBZSxFQUFFLGNBQWMsRUFBRSxDQUFDLENBQUM7U0FDL0Y7YUFBTTtZQUNMLElBQUksQ0FBQyxHQUFHLEdBQUcsSUFBSSxPQUFPLEVBQUUsQ0FBQztTQUMxQjtJQUNILENBQUM7SUFFTSxjQUFjO1FBQ25CLE9BQU8sT0FBTyxDQUFDLE9BQU8sQ0FBQyxFQUFFLFNBQVMsRUFBRSxjQUFjLEVBQUUsU0FBUyxFQUFFLEtBQUssRUFBRSxDQUFDLENBQUM7SUFDMUUsQ0FBQztJQUVNLGNBQWM7UUFDbkIsT0FBTyxPQUFPLENBQUMsT0FBTyxDQUFDLElBQUksQ0FB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O0FBQ2IsQ0FBQztBQUpELHNDQUlDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICogYXMgY3hhcGkgZnJvbSAnQGF3cy1jZGsvY3gtYXBpJztcbmltcG9ydCAqIGFzIEFXUyBmcm9tICdhd3Mtc2RrJztcbmltcG9ydCB7IEFjY291bnQsIElTREssIFNESywgU2RrUHJvdmlkZXIsIFRvb2xraXRJbmZvIH0gZnJvbSAnLi4vLi4vbGliJztcbmltcG9ydCB7IENsb3VkRm9ybWF0aW9uU3RhY2sgfSBmcm9tICcuLi8uLi9saWIvYXBpL3V0aWwvY2xvdWRmb3JtYXRpb24nO1xuXG5jb25zdCBGQUtFX0NSRURFTlRJQUxTID0gbmV3IEFXUy5DcmVkZW50aWFscyh7IGFjY2Vzc0tleUlkOiAnQUNDRVNTJywgc2VjcmV0QWNjZXNzS2V5OiAnU0VDUkVUJywgc2Vzc2lvblRva2VuOiAnVE9LRU4gJyB9KTtcblxuY29uc3QgRkFLRV9DUkVERU5USUFMX0NIQUlOID0gbmV3IEFXUy5DcmVkZW50aWFsUHJvdmlkZXJDaGFpbihbXG4gICgpID0+IEZBS0VfQ1JFREVOVElBTFMsXG5dKTtcblxuZXhwb3J0IGludGVyZmFjZSBNb2NrU2RrUHJvdmlkZXJPcHRpb25zIHtcbiAgLyoqXG4gICAqIFdoZXRoZXIgdGhlIG1vY2sgcHJvdmlkZXIgc2hvdWxkIHByb2R1Y2UgYSByZWFsIFNES1xuICAgKlxuICAgKiBTb21lIHRlc3RzIHJlcXVpcmUgYSByZWFsIFNESyBiZWNhdXNlIHRoZXkgdXNlIGBBV1MtbW9ja2AgdG8gcmVwbGFjZVxuICAgKiB0aGUgdW5kZXJseWluZyBjYWxscy4gT3RoZXIgdGVzdHMgZG8gdGhlaXIgd29yayBjb21wbGV0ZWx5IHVzaW5nIGplc3QtbW9ja3MuXG4gICAqXG4gICAqIEBkZWZhdWx0IHRydWVcbiAgICovXG4gIHJlYWRvbmx5IHJlYWxTZGs/OiBib29sZWFuO1xufVxuXG4vKipcbiAqIEFuIFNESyB0aGF0IGFsbG93cyByZXBsYWNpbmcgKHNvbWUgb2YpIHRoZSBjbGllbnRzXG4gKlxuICogSXRzIHRoZSByZXNwb25zaWJpbGl0eSBvZiB0aGUgY29uc3VtZXIgdG8gcmVwbGFjZSBhbGwgY2FsbHMgdGhhdFxuICogYWN0dWFsbHkgd2lsbCBiZSBjYWxsZWQuXG4gKi9cbmV4cG9ydCBjbGFzcyBNb2NrU2RrUHJvdmlkZXIgZXh0ZW5kcyBTZGtQcm92aWRlciB7XG4gIHByaXZhdGUgcmVhZG9ubHkgc2RrOiBJU0RLO1xuXG4gIGNvbnN0cnVjdG9yKG9wdGlvbnM6IE1vY2tTZGtQcm92aWRlck9wdGlvbnMgPSB7fSkge1xuICAgIHN1cGVyKEZBS0VfQ1JFREVOVElBTF9DSEFJTiwgJ2Jlcm11ZGEtdHJpYW5nbGUtMTMzNycsIHsgY3VzdG9tVXNlckFnZW50OiAnYXdzLWNkay9qZXN0JyB9KTtcblxuICAgIC8vIFNESyBjb250YWlucyBhIHJlYWwgU0RLLCBzaW5jZSBzb21lIHRlc3QgdXNlICdBV1MtbW9jaycgdG8gcmVwbGFjZSB0aGUgdW5kZXJseWluZ1xuICAgIC8vIEFXUyBjYWxscyB3aGljaCBhIHJlYWwgU0RLIHdvdWxkIGRvLCBhbmQgc29tZSB0ZXN0cyB1c2UgdGhlICdzdHViJyBmdW5jdGlvbmFsaXR5IGJlbG93LlxuICAgIGlmIChvcHRpb25zLnJlYWxTZGsgPz8gdHJ1ZSkge1xuICAgICAgdGhpcy5zZGsgPSBuZXcgU0RLKEZBS0VfQ1JFREVOVElBTFMsIHRoaXMuZGVmYXVsdFJlZ2lvbiwgeyBjdXN0b21Vc2VyQWdlbnQ6ICdhd3MtY2RrL2plc3QnIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnNkayA9IG5ldyBNb2NrU2RrKCk7XG4gICAgfVxuICB9XG5cbiAgcHVibGljIGRlZmF1bHRBY2NvdW50KCk6IFByb21pc2U8QWNjb3VudCB8IHVuZGVmaW5lZD4ge1xuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoeyBhY2NvdW50SWQ6ICcxMjM0NTY3ODkwMTInLCBwYXJ0aXRpb246ICdhd3MnIH0pO1xuICB9XG5cbiAgcHVibGljIGZvckVudmlyb25tZW50KCk6IFByb21pc2U8SVNESz4ge1xuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUodGhpcy5zZGspO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlcGxhY2UgdGhlIENsb3VkRm9ybWF0aW9uIGNsaWVudCB3aXRoIHRoZSBnaXZlbiBvYmplY3RcbiAgICovXG4gIHB1YmxpYyBzdHViQ2xvdWRGb3JtYXRpb24oc3R1YnM6IFN5bmNIYW5kbGVyU3Vic2V0T2Y8QVdTLkNsb3VkRm9ybWF0aW9uPikge1xuICAgICh0aGlzLnNkayBhcyBhbnkpLmNsb3VkRm9ybWF0aW9uID0gamVzdC5mbigpLm1vY2tSZXR1cm5WYWx1ZShwYXJ0aWFsQXdzU2VydmljZTxBV1MuQ2xvdWRGb3JtYXRpb24+KHN0dWJzKSk7XG4gIH1cblxuICAvKipcbiAgICogUmVwbGFjZSB0aGUgRUNSIGNsaWVudCB3aXRoIHRoZSBnaXZlbiBvYmplY3RcbiAgICovXG4gIHB1YmxpYyBzdHViRWNyKHN0dWJzOiBTeW5jSGFuZGxlclN1YnNldE9mPEFXUy5FQ1I+KSB7XG4gICAgKHRoaXMuc2RrIGFzIGFueSkuZWNyID0gamVzdC5mbigpLm1vY2tSZXR1cm5WYWx1ZShwYXJ0aWFsQXdzU2VydmljZTxBV1MuRUNSPihzdHVicykpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlcGxhY2UgdGhlIFMzIGNsaWVudCB3aXRoIHRoZSBnaXZlbiBvYmplY3RcbiAgICovXG4gIHB1YmxpYyBzdHViUzMoc3R1YnM6IFN5bmNIYW5kbGVyU3Vic2V0T2Y8QVdTLlMzPikge1xuICAgICh0aGlzLnNkayBhcyBhbnkpLnMzID0gamVzdC5mbigpLm1vY2tSZXR1cm5WYWx1ZShwYXJ0aWFsQXdzU2VydmljZTxBV1MuUzM+KHN0dWJzKSk7XG4gIH1cblxuICAvKipcbiAgICogUmVwbGFjZSB0aGUgU1RTIGNsaWVudCB3aXRoIHRoZSBnaXZlbiBvYmplY3RcbiAgICovXG4gIHB1YmxpYyBzdHViU1RTKHN0dWJzOiBTeW5jSGFuZGxlclN1YnNldE9mPEFXUy5TVFM+KSB7XG4gICAgKHRoaXMuc2RrIGFzIGFueSkuc3RzID0gamVzdC5mbigpLm1vY2tSZXR1cm5WYWx1ZShwYXJ0aWFsQXdzU2VydmljZTxBV1MuU1RTPihzdHVicykpO1xuICB9XG59XG5cbmV4cG9ydCBjbGFzcyBNb2NrU2RrIGltcGxlbWVudHMgSVNESyB7XG4gIHB1YmxpYyByZWFkb25seSBjdXJyZW50UmVnaW9uOiBzdHJpbmcgPSAnYmVybXVkYS10cmlhbmdsZS0xMzM3JztcbiAgcHVibGljIHJlYWRvbmx5IGNsb3VkRm9ybWF0aW9uID0gamVzdC5mbigpO1xuICBwdWJsaWMgcmVhZG9ubHkgZWMyID0gamVzdC5mbigpO1xuICBwdWJsaWMgcmVhZG9ubHkgc3NtID0gamVzdC5mbigpO1xuICBwdWJsaWMgcmVhZG9ubHkgczMgPSBqZXN0LmZuKCk7XG4gIHB1YmxpYyByZWFkb25seSByb3V0ZTUzID0gamVzdC5mbigpO1xuICBwdWJsaWMgcmVhZG9ubHkgZWNyID0gamVzdC5mbigpO1xuXG4gIHB1YmxpYyBjdXJyZW50QWNjb3VudCgpOiBQcm9taXNlPEFjY291bnQ+IHtcbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHsgYWNjb3VudElkOiAnMTIzNDU2Nzg5MDEyJywgcGFydGl0aW9uOiAnYXdzJyB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXBsYWNlIHRoZSBDbG91ZEZvcm1hdGlvbiBjbGllbnQgd2l0aCB0aGUgZ2l2ZW4gb2JqZWN0XG4gICAqL1xuICBwdWJsaWMgc3R1YkNsb3VkRm9ybWF0aW9uKHN0dWJzOiBTeW5jSGFuZGxlclN1YnNldE9mPEFXUy5DbG91ZEZvcm1hdGlvbj4pIHtcbiAgICB0aGlzLmNsb3VkRm9ybWF0aW9uLm1vY2tSZXR1cm5WYWx1ZShwYXJ0aWFsQXdzU2VydmljZTxBV1MuQ2xvdWRGb3JtYXRpb24+KHN0dWJzKSk7XG4gIH1cblxuICAvKipcbiAgICogUmVwbGFjZSB0aGUgRUNSIGNsaWVudCB3aXRoIHRoZSBnaXZlbiBvYmplY3RcbiAgICovXG4gIHB1YmxpYyBzdHViRWNyKHN0dWJzOiBTeW5jSGFuZGxlclN1YnNldE9mPEFXUy5FQ1I+KSB7XG4gICAgdGhpcy5lY3IubW9ja1JldHVyblZhbHVlKHBhcnRpYWxBd3NTZXJ2aWNlPEFXUy5FQ1I+KHN0dWJzKSk7XG4gIH1cbn1cblxuLyoqXG4gKiBXcmFwIHN5bmNocm9ub3VzIGZha2UgaGFuZGxlcnMgc28gdGhhdCB0aGV5IHNvcnQtb2YgZnVuY3Rpb24gbGlrZSBhIHJlYWwgQVdTIGNsaWVudFxuICpcbiAqIEZvciBleGFtcGxlLCB0dXJucyBhbiBvYmplY3QgbGlrZSB0aGlzOlxuICpcbiAqIGBgYHRzXG4gKiB7XG4gKiAgIHNvbWVDYWxsKG9wdHM6IEFXUy5TZXJ2aWNlLlNvbWVDYWxsSW5wdXQpOiBBV1MuU2VydmljZS5Tb21lQ2FsbE91dHB1dCB7XG4gKiAgICAgcmV0dXJuIHsuLi53aGF0ZXZlci4uLn07XG4gKiAgIH1cbiAqIH1cbiAqIGBgYFxuICpcbiAqIEludG8gYW4gb2JqZWN0IHRoYXQgaW4gdGhlIHR5cGUgc3lzdGVtIHByZXRlbmRzIHRvIGJlIGFuICdBV1MuU2VydmljZSdcbiAqIGNsYXNzIChldmVuIHRob3VnaCBpdCByZWFsbHkgaXNuJ3QpIGFuZCBjYW4gYmUgY2FsbGVkIGxpa2UgdGhpczpcbiAqXG4gKiBgYGB0c1xuICogY29uc3Qgc2VydmljZSA9IGF3YWl0IHNkay5zb21lU2VydmljZSguLi4pO1xuICogY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBzZXJ2aWNlLnNvbWVDYWxsKC4uLikucHJvbWlzZSgpO1xuICogYGBgXG4gKlxuICogV2Ugb25seSBpbXBsZW1lbnQgdGhlIG5hcnJvdyBzdWJzZXQgb2YgdGhlIEFXUyBTREsgQVBJIHRoYXQgdGhlIENESyBhY3R1YWxseVxuICogdXNlcywgYW5kIHdlIGNoZWF0IG9uIHRoZSB0eXBlcyB0byBtYWtlIFR5cGVTY3JpcHQgaGFwcHkgb24gdGhlIHJlc3Qgb2YgdGhlIEFQSS5cbiAqXG4gKiBNb3N0IGltcG9ydGFudCBmZWF0dXJlIG9mIHRoaXMgY2xhc3MgaXMgdGhhdCBpdCB3aWxsIGRlcml2ZSB0aGUgaW5wdXQgYW5kIG91dHB1dFxuICogdHlwZXMgb2YgdGhlIGhhbmRsZXJzIG9uIHRoZSBpbnB1dCBvYmplY3QgZnJvbSB0aGUgQUNUVUFMIEFXUyBTZXJ2aWNlIGNsYXNzLFxuICogc28gdGhhdCB5b3UgZG9uJ3QgaGF2ZSB0byBkZWNsYXJlIHRoZW0uXG4gKi9cbmZ1bmN0aW9uIHBhcnRpYWxBd3NTZXJ2aWNlPFM+KGZuczogU3luY0hhbmRsZXJTdWJzZXRPZjxTPik6IFMge1xuICAvLyBTdXBlciB1bnNhZmUgaW4gaGVyZSBiZWNhdXNlIEkgZG9uJ3Qga25vdyBob3cgdG8gbWFrZSBUeXBlU2NyaXB0IGhhcHB5LFxuICAvLyBidXQgYXQgbGVhc3QgdGhlIG91dGVyIHR5cGVzIG1ha2Ugc3VyZSBldmVyeXRoaW5nIHRoYXQgaGFwcGVucyBpbiBoZXJlIHdvcmtzIG91dC5cbiAgY29uc3QgcmV0OiBhbnkgPSB7fTtcblxuICBmb3IgKGNvbnN0IFtrZXksIGhhbmRsZXJdIG9mIE9iamVjdC5lbnRyaWVzKGZucykpIHtcbiAgICByZXRba2V5XSA9IChhcmdzOiBhbnkpID0+IG5ldyBGYWtlQVdTUmVzcG9uc2UoKGhhbmRsZXIgYXMgYW55KShhcmdzKSk7XG4gIH1cblxuICByZXR1cm4gcmV0O1xufVxuXG4vLyBCZWNhdXNlIG9mIHRoZSBvdmVybG9hZHMgYW4gQVdTIGhhbmRsZXIgdHlwZSBsb29rcyBsaWtlIHRoaXM6XG4vL1xuLy8gICB7XG4vLyAgICAgIChwYXJhbXM6IElOUFVUU1RSVUNULCBjYWxsYmFjaz86ICgoZXJyOiBBV1NFcnJvciwgZGF0YToge30pID0+IHZvaWQpIHwgdW5kZWZpbmVkKTogUmVxdWVzdDxPVVRQVVQsIC4uLj47XG4vLyAgICAgIChjYWxsYmFjaz86ICgoZXJyOiBBV1MuQVdTRXJyb3IsIGRhdGE6IHt9KSA9PiB2b2lkKSB8IHVuZGVmaW5lZCk6IEFXUy5SZXF1ZXN0PC4uLj47XG4vLyAgIH1cbi8vXG4vLyBHZXQgdGhlIGZpcnN0IG92ZXJsb2FkIGFuZCBleHRyYWN0IHRoZSBpbnB1dCBhbmQgb3V0cHV0IHN0cnVjdCB0eXBlc1xudHlwZSBBd3NDYWxsSW5wdXRPdXRwdXQ8VD4gPVxuICAgIFQgZXh0ZW5kcyB7XG4gICAgICAoYXJnczogaW5mZXIgSU5QVVQsIGNhbGxiYWNrPzogKChlcnI6IEFXUy5BV1NFcnJvciwgZGF0YTogYW55KSA9PiB2b2lkKSB8IHVuZGVmaW5lZCk6IEFXUy5SZXF1ZXN0PGluZmVyIE9VVFBVVCwgQVdTLkFXU0Vycm9yPjtcbiAgICAgIChjYWxsYmFjaz86ICgoZXJyOiBBV1MuQVdTRXJyb3IsIGRhdGE6IHt9KSA9PiB2b2lkKSB8IHVuZGVmaW5lZCk6IEFXUy5SZXF1ZXN0PGFueSwgYW55PjtcbiAgICB9ID8gW0lOUFVULCBPVVRQVVRdIDogVDtcblxuLy8gRGV0ZXJtaW5lIHRoZSB0eXBlIG9mIHRoZSBtb2NrIGhhbmRsZXIgZnJvbSB0aGUgdHlwZSBvZiB0aGUgSW5wdXQvT3V0cHV0IHR5cGUgcGFpci5cbi8vIERvbid0IG5lZWQgdG8gd29ycnkgYWJvdXQgdGhlICduZXZlcicsIFR5cGVTY3JpcHQgd2lsbCBwcm9wYWdhdGUgaXQgdXB3YXJkcyBtYWtpbmcgaXRcbi8vIGltcG9zc2libGUgdG8gc3BlY2lmeSB0aGUgZmllbGQgdGhhdCBoYXMgJ25ldmVyJyBhbnl3aGVyZSBpbiBpdHMgdHlwZS5cbnR5cGUgTW9ja0hhbmRsZXJUeXBlPEFJPiA9XG4gICAgQUkgZXh0ZW5kcyBbYW55LCBhbnldID8gKGlucHV0OiBBSVswXSkgPT4gQUlbMV0gOiBBSTtcblxuLy8gQW55IHN1YnNldCBvZiB0aGUgZnVsbCB0eXBlIHRoYXQgc3luY2hyb25vdXNseSByZXR1cm5zIHRoZSBvdXRwdXQgc3RydWN0dXJlIGlzIG9rYXlcbmV4cG9ydCB0eXBlIFN5bmNIYW5kbGVyU3Vic2V0T2Y8Uz4gPSB7W0sgaW4ga2V5b2YgU10/OiBNb2NrSGFuZGxlclR5cGU8QXdzQ2FsbElucHV0T3V0cHV0PFNbS10+Pn07XG5cbi8qKlxuICogRmFrZSBBV1MgcmVzcG9uc2UuXG4gKlxuICogV2Ugb25seSBldmVyICdhd2FpdCByZXNwb25zZS5wcm9taXNlKCknIHNvIHRoYXQncyB0aGUgb25seSB0aGluZyB3ZSBpbXBsZW1lbnQgaGVyZS5cbiAqL1xuY2xhc3MgRmFrZUFXU1Jlc3BvbnNlPFQ+IHtcbiAgY29uc3RydWN0b3IocHJpdmF0ZSByZWFkb25seSB4OiBUKSB7XG4gIH1cblxuICBwdWJsaWMgcHJvbWlzZSgpOiBQcm9taXNlPFQ+IHtcbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHRoaXMueCk7XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIG1vY2tCb290c3RyYXBTdGFjayhzZGs6IElTREsgfCB1bmRlZmluZWQsIHN0YWNrPzogUGFydGlhbDxBV1MuQ2xvdWRGb3JtYXRpb24uU3RhY2s+KSB7XG4gIHJldHVybiBDbG91ZEZvcm1hdGlvblN0YWNrLmZyb21TdGF0aWNJbmZvcm1hdGlvbigoc2RrID8/IG5ldyBNb2NrU2RrKCkpLmNsb3VkRm9ybWF0aW9uKCksICdDREtUb29sa2l0Jywge1xuICAgIENyZWF0aW9uVGltZTogbmV3IERhdGUoKSxcbiAgICBTdGFja05hbWU6ICdDREtUb29sa2l0JyxcbiAgICBTdGFja1N0YXR1czogJ0NSRUFURV9DT01QTEVURScsXG4gICAgT3V0cHV0czogW1xuICAgICAgeyBPdXRwdXRLZXk6ICdCdWNrZXROYW1lJywgT3V0cHV0VmFsdWU6ICdCVUNLRVRfTkFNRScgfSxcbiAgICAgIHsgT3V0cHV0S2V5OiAnQnVja2V0RG9tYWluTmFtZScsIE91dHB1dFZhbHVlOiAnQlVDS0VUX0VORFBPSU5UJyB9LFxuICAgICAgeyBPdXRwdXRLZXk6ICdCb290c3RyYXBWZXJzaW9uJywgT3V0cHV0VmFsdWU6ICcxJyB9LFxuICAgIF0sXG4gICAgLi4uc3RhY2ssXG4gIH0pO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gbW9ja1Rvb2xraXRJbmZvKHN0YWNrPzogUGFydGlhbDxBV1MuQ2xvdWRGb3JtYXRpb24uU3RhY2s+KSB7XG4gIGNvbnN0IHNkayA9IG5ldyBNb2NrU2RrKCk7XG4gIHJldHVybiBuZXcgVG9vbGtpdEluZm8obW9ja0Jvb3RzdHJhcFN0YWNrKHNkaywgc3RhY2spLCBzZGspO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gbW9ja1Jlc29sdmVkRW52aXJvbm1lbnQoKTogY3hhcGkuRW52aXJvbm1lbnQge1xuICByZXR1cm4ge1xuICAgIGFjY291bnQ6ICcxMjM0NTY3ODknLFxuICAgIHJlZ2lvbjogJ2Jlcm11ZGEtdHJpYW5nbGUtMTMzNycsXG4gICAgbmFtZTogJ2F3czovLzEyMzQ1Njc4OS9iZXJtdWRhLXRyaWFuZ2xlLTEzMzcnLFxuICB9O1xufVxuXG4vLyBKZXN0IGhlbHBlcnNcblxuLy8gQW4gb2JqZWN0IG9uIHdoaWNoIGFsbCBjYWxsYWJsZXMgYXJlIEplc3QgTW9ja3NcbmV4cG9ydCB0eXBlIE1vY2tlZE9iamVjdDxTIGV4dGVuZHMgb2JqZWN0PiA9IHtbSyBpbiBrZXlvZiBTXTogTW9ja2VkRnVuY3Rpb248UmVxdWlyZWQ8Uz5bS10+fTtcblxuLy8gSWYgYSBmdW5jdGlvbiwgdGhlbiBhIG1vY2tlZCB2ZXJzaW9uIG9mIGl0LCBvdGhlcndpc2UganVzdCBUXG50eXBlIE1vY2tlZEZ1bmN0aW9uPFQ+ID0gVCBleHRlbmRzICguLi5hcmdzOiBhbnlbXSkgPT4gYW55XG4gID8gamVzdC5Nb2NrSW5zdGFuY2U8UmV0dXJuVHlwZTxUPiwgamVzdC5BcmdzVHlwZTxUPj5cbiAgOiBUO1xuZXhwb3J0IGZ1bmN0aW9uIGVycm9yV2l0aENvZGUoY29kZTogc3RyaW5nLCBtZXNzYWdlOiBzdHJpbmcpIHtcbiAgY29uc3QgcmV0ID0gbmV3IEVycm9yKG1lc3NhZ2UpO1xuICAocmV0IGFzIGFueSkuY29kZSA9IGNvZGU7XG4gIHJldHVybiByZXQ7XG59XG4iXX0=