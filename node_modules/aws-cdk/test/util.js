"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.withMockedClassSingleton = exports.instanceMockFrom = exports.testStack = exports.testAssembly = exports.MockCloudExecutable = exports.DEFAULT_FAKE_TEMPLATE = void 0;
const fs = require("fs");
const path = require("path");
const cxschema = require("@aws-cdk/cloud-assembly-schema");
const cxapi = require("@aws-cdk/cx-api");
const cloud_executable_1 = require("../lib/api/cxapp/cloud-executable");
const settings_1 = require("../lib/settings");
const mock_sdk_1 = require("./util/mock-sdk");
exports.DEFAULT_FAKE_TEMPLATE = { No: 'Resources' };
class MockCloudExecutable extends cloud_executable_1.CloudExecutable {
    constructor(assembly) {
        const configuration = new settings_1.Configuration();
        const sdkProvider = new mock_sdk_1.MockSdkProvider();
        super({
            configuration,
            sdkProvider,
            synthesizer: () => Promise.resolve(testAssembly(assembly)),
        });
        this.configuration = configuration;
        this.sdkProvider = sdkProvider;
    }
}
exports.MockCloudExecutable = MockCloudExecutable;
function clone(obj) {
    return JSON.parse(JSON.stringify(obj));
}
function testAssembly(assembly) {
    var _a;
    const builder = new cxapi.CloudAssemblyBuilder();
    for (const stack of assembly.stacks) {
        const templateFile = `${stack.stackName}.template.json`;
        const template = (_a = stack.template) !== null && _a !== void 0 ? _a : exports.DEFAULT_FAKE_TEMPLATE;
        fs.writeFileSync(path.join(builder.outdir, templateFile), JSON.stringify(template, undefined, 2));
        // we call patchStackTags here to simulate the tags formatter
        // that is used when building real manifest files.
        const metadata = patchStackTags({ ...stack.metadata });
        for (const asset of stack.assets || []) {
            metadata[asset.id] = [
                { type: cxschema.ArtifactMetadataEntryType.ASSET, data: asset },
            ];
        }
        for (const missing of assembly.missing || []) {
            builder.addMissing(missing);
        }
        builder.addArtifact(stack.stackName, {
            type: cxschema.ArtifactType.AWS_CLOUDFORMATION_STACK,
            environment: stack.env || 'aws://12345/here',
            dependencies: stack.depends,
            metadata,
            properties: {
                ...stack.properties,
                templateFile,
                terminationProtection: stack.terminationProtection,
            },
        });
    }
    return builder.buildAssembly();
}
exports.testAssembly = testAssembly;
/**
 * Transform stack tags from how they are decalred in source code (lower cased)
 * to how they are stored on disk (upper cased). In real synthesis this is done
 * by a special tags formatter.
 *
 * @see @aws-cdk/core/lib/stack.ts
 */
function patchStackTags(metadata) {
    const cloned = clone(metadata);
    for (const metadataEntries of Object.values(cloned)) {
        for (const metadataEntry of metadataEntries) {
            if (metadataEntry.type === cxschema.ArtifactMetadataEntryType.STACK_TAGS && metadataEntry.data) {
                const metadataAny = metadataEntry;
                metadataAny.data = metadataAny.data.map((t) => {
                    return { Key: t.key, Value: t.value };
                });
            }
        }
    }
    return cloned;
}
function testStack(stack) {
    const assembly = testAssembly({ stacks: [stack] });
    return assembly.getStackByName(stack.stackName);
}
exports.testStack = testStack;
/**
 * Return a mocked instance of a class, given its constructor
 *
 * I don't understand why jest doesn't provide this by default,
 * but there you go.
 *
 * FIXME: Currently very limited. Doesn't support inheritance, getters or
 * automatic detection of properties (as those exist on instances, not
 * classes).
 */
function instanceMockFrom(ctr) {
    const ret = {};
    for (const methodName of Object.getOwnPropertyNames(ctr.prototype)) {
        ret[methodName] = jest.fn();
    }
    return ret;
}
exports.instanceMockFrom = instanceMockFrom;
/**
 * Run an async block with a class (constructor) replaced with a mock
 *
 * The class constructor will be replaced with a constructor that returns
 * a singleton, and the singleton will be passed to the block so that its
 * methods can be mocked individually.
 *
 * Uses `instanceMockFrom` so is subject to the same limitations that hold
 * for that function.
 */
async function withMockedClassSingleton(obj, key, cb) {
    const original = obj[key];
    try {
        const mock = instanceMockFrom(original);
        obj[key] = jest.fn().mockReturnValue(mock);
        const ret = await cb(mock);
        return ret;
    }
    finally {
        obj[key] = original;
    }
}
exports.withMockedClassSingleton = withMockedClassSingleton;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidXRpbC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbInV0aWwudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7O0FBQUEseUJBQXlCO0FBQ3pCLDZCQUE2QjtBQUM3QiwyREFBMkQ7QUFDM0QseUNBQXlDO0FBQ3pDLHdFQUFvRTtBQUNwRSw4Q0FBZ0Q7QUFDaEQsOENBQWtEO0FBRXJDLFFBQUEscUJBQXFCLEdBQUcsRUFBRSxFQUFFLEVBQUUsV0FBVyxFQUFFLENBQUM7QUFrQnpELE1BQWEsbUJBQW9CLFNBQVEsa0NBQWU7SUFJdEQsWUFBWSxRQUFzQjtRQUNoQyxNQUFNLGFBQWEsR0FBRyxJQUFJLHdCQUFhLEVBQUUsQ0FBQztRQUMxQyxNQUFNLFdBQVcsR0FBRyxJQUFJLDBCQUFlLEVBQUUsQ0FBQztRQUUxQyxLQUFLLENBQUM7WUFDSixhQUFhO1lBQ2IsV0FBVztZQUNYLFdBQVcsRUFBRSxHQUFHLEVBQUUsQ0FBQyxPQUFPLENBQUMsT0FBTyxDQUFDLFlBQVksQ0FBQyxRQUFRLENBQUMsQ0FBQztTQUMzRCxDQUFDLENBQUM7UUFFSCxJQUFJLENBQUMsYUFBYSxHQUFHLGFBQWEsQ0FBQztRQUNuQyxJQUFJLENBQUMsV0FBVyxHQUFHLFdBQVcsQ0FBQztJQUNqQyxDQUFDO0NBQ0Y7QUFqQkQsa0RBaUJDO0FBRUQsU0FBUyxLQUFLLENBQUMsR0FBUTtJQUNyQixPQUFPLElBQUksQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLFNBQVMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDO0FBQ3pDLENBQUM7QUFFRCxTQUFnQixZQUFZLENBQUMsUUFBc0I7O0lBQ2pELE1BQU0sT0FBTyxHQUFHLElBQUksS0FBSyxDQUFDLG9CQUFvQixFQUFFLENBQUM7SUFFakQsS0FBSyxNQUFNLEtBQUssSUFBSSxRQUFRLENBQUMsTUFBTSxFQUFFO1FBQ25DLE1BQU0sWUFBWSxHQUFHLEdBQUcsS0FBSyxDQUFDLFNBQVMsZ0JBQWdCLENBQUM7UUFDeEQsTUFBTSxRQUFRLFNB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LElBQUksQ0FBQyxFQUFFLEVBQUUsQ0FBQztLQUM3QjtJQUNELE9BQU8sR0FBRyxDQUFDO0FBQ2IsQ0FBQztBQU5ELDRDQU1DO0FBRUQ7Ozs7Ozs7OztHQVNHO0FBQ0ksS0FBSyxVQUFVLHdCQUF3QixDQUM1QyxHQUFNLEVBQ04sR0FBTSxFQUNOLEVBQW1HO0lBR25HLE1BQU0sUUFBUSxHQUFHLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQztJQUMxQixJQUFJO1FBQ0YsTUFBTSxJQUFJLEdBQUcsZ0JBQWdCLENBQUMsUUFBZSxDQUFDLENBQUM7UUFDL0MsR0FBRyxDQUFDLEdBQUcsQ0FBQyxHQUFHLElBQUksQ0FBQyxFQUFFLEVBQUUsQ0FBQyxlQUFlLENBQUMsSUFBSSxDQUFRLENBQUM7UUFDbEQsTUFBTSxHQUFHLEdBQUcsTUFBTSxFQUFFLENBQUMsSUFBVyxDQUFDLENBQUM7UUFDbEMsT0FBTyxHQUFHLENBQUM7S0FDWjtZQUFTO1FBQ1IsR0FBRyxDQUFDLEdBQUcsQ0FBQyxHQUFHLFFBQVEsQ0FBQztLQUNyQjtBQUNILENBQUM7QUFmRCw0REFlQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAqIGFzIGZzIGZyb20gJ2ZzJztcbmltcG9ydCAqIGFzIHBhdGggZnJvbSAncGF0aCc7XG5pbXBvcnQgKiBhcyBjeHNjaGVtYSBmcm9tICdAYXdzLWNkay9jbG91ZC1hc3NlbWJseS1zY2hlbWEnO1xuaW1wb3J0ICogYXMgY3hhcGkgZnJvbSAnQGF3cy1jZGsvY3gtYXBpJztcbmltcG9ydCB7IENsb3VkRXhlY3V0YWJsZSB9IGZyb20gJy4uL2xpYi9hcGkvY3hhcHAvY2xvdWQtZXhlY3V0YWJsZSc7XG5pbXBvcnQgeyBDb25maWd1cmF0aW9uIH0gZnJvbSAnLi4vbGliL3NldHRpbmdzJztcbmltcG9ydCB7IE1vY2tTZGtQcm92aWRlciB9IGZyb20gJy4vdXRpbC9tb2NrLXNkayc7XG5cbmV4cG9ydCBjb25zdCBERUZBVUxUX0ZBS0VfVEVNUExBVEUgPSB7IE5vOiAnUmVzb3VyY2VzJyB9O1xuXG5leHBvcnQgaW50ZXJmYWNlIFRlc3RTdGFja0FydGlmYWN0IHtcbiAgc3RhY2tOYW1lOiBzdHJpbmc7XG4gIHRlbXBsYXRlPzogYW55O1xuICBlbnY/OiBzdHJpbmcsXG4gIGRlcGVuZHM/OiBzdHJpbmdbXTtcbiAgbWV0YWRhdGE/OiBjeGFwaS5TdGFja01ldGFkYXRhO1xuICBhc3NldHM/OiBjeHNjaGVtYS5Bc3NldE1ldGFkYXRhRW50cnlbXTtcbiAgcHJvcGVydGllcz86IFBhcnRpYWw8Y3hzY2hlbWEuQXdzQ2xvdWRGb3JtYXRpb25TdGFja1Byb3BlcnRpZXM+O1xuICB0ZXJtaW5hdGlvblByb3RlY3Rpb24/OiBib29sZWFuO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFRlc3RBc3NlbWJseSB7XG4gIHN0YWNrczogVGVzdFN0YWNrQXJ0aWZhY3RbXTtcbiAgbWlzc2luZz86IGN4c2NoZW1hLk1pc3NpbmdDb250ZXh0W107XG59XG5cbmV4cG9ydCBjbGFzcyBNb2NrQ2xvdWRFeGVjdXRhYmxlIGV4dGVuZHMgQ2xvdWRFeGVjdXRhYmxlIHtcbiAgcHVibGljIHJlYWRvbmx5IGNvbmZpZ3VyYXRpb246IENvbmZpZ3VyYXRpb247XG4gIHB1YmxpYyByZWFkb25seSBzZGtQcm92aWRlcjogTW9ja1Nka1Byb3ZpZGVyO1xuXG4gIGNvbnN0cnVjdG9yKGFzc2VtYmx5OiBUZXN0QXNzZW1ibHkpIHtcbiAgICBjb25zdCBjb25maWd1cmF0aW9uID0gbmV3IENvbmZpZ3VyYXRpb24oKTtcbiAgICBjb25zdCBzZGtQcm92aWRlciA9IG5ldyBNb2NrU2RrUHJvdmlkZXIoKTtcblxuICAgIHN1cGVyKHtcbiAgICAgIGNvbmZpZ3VyYXRpb24sXG4gICAgICBzZGtQcm92aWRlcixcbiAgICAgIHN5bnRoZXNpemVyOiAoKSA9PiBQcm9taXNlLnJlc29sdmUodGVzdEFzc2VtYmx5KGFzc2VtYmx5KSksXG4gICAgfSk7XG5cbiAgICB0aGlzLmNvbmZpZ3VyYXRpb24gPSBjb25maWd1cmF0aW9uO1xuICAgIHRoaXMuc2RrUHJvdmlkZXIgPSBzZGtQcm92aWRlcjtcbiAgfVxufVxuXG5mdW5jdGlvbiBjbG9uZShvYmo6IGFueSkge1xuICByZXR1cm4gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShvYmopKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHRlc3RBc3NlbWJseShhc3NlbWJseTogVGVzdEFzc2VtYmx5KTogY3hhcGkuQ2xvdWRBc3NlbWJseSB7XG4gIGNvbnN0IGJ1aWxkZXIgPSBuZXcgY3hhcGkuQ2xvdWRBc3NlbWJseUJ1aWxkZXIoKTtcblxuICBmb3IgKGNvbnN0IHN0YWNrIG9mIGFzc2VtYmx5LnN0YWNrcykge1xuICAgIGNvbnN0IHRlbXBsYXRlRmlsZSA9IGAke3N0YWNrLnN0YWNrTmFtZX0udGVtcGxhdGUuanNvbmA7XG4gICAgY29uc3QgdGVtcGxhdGUgPSBzdGFjay50ZW1wbGF0ZSA/PyBERUZBVUxUX0ZBS0VfVEVNUExBVEU7XG4gICAgZnMud3JpdGVGaWxlU3luYyhwYXRoLmpvaW4oYnVpbGRlci5vdXRkaXIsIHRlbXBsYXRlRmlsZSksIEpTT04uc3RyaW5naWZ5KHRlbXBsYXRlLCB1bmRlZmluZWQsIDIpKTtcblxuICAgIC8vIHdlIGNhbGwgcGF0Y2hTdGFja1RhZ3MgaGVyZSB0byBzaW11bGF0ZSB0aGUgdGFncyBmb3JtYXR0ZXJcbiAgICAvLyB0aGF0IGlzIHVzZWQgd2hlbiBidWlsZGluZyByZWFsIG1hbmlmZXN0IGZpbGVzLlxuICAgIGNvbnN0IG1ldGFkYXRhOiB7IFtwYXRoOiBzdHJpbmddOiBjeHNjaGVtYS5NZXRhZGF0YUVudHJ5W10gfSA9IHBhdGNoU3RhY2tUYWdzKHsgLi4uc3RhY2subWV0YWRhdGEgfSk7XG4gICAgZm9yIChjb25zdCBhc3NldCBvZiBzdGFjay5hc3NldHMgfHwgW10pIHtcbiAgICAgIG1ldGFkYXRhW2Fzc2V0LmlkXSA9IFtcbiAgICAgICAgeyB0eXBlOiBjeHNjaGVtYS5BcnRpZmFjdE1ldGFkYXRhRW50cnlUeXBlLkFTU0VULCBkYXRhOiBhc3NldCB9LFxuICAgICAgXTtcbiAgICB9XG5cbiAgICBmb3IgKGNvbnN0IG1pc3Npbmcgb2YgYXNzZW1ibHkubWlzc2luZyB8fCBbXSkge1xuICAgICAgYnVpbGRlci5hZGRNaXNzaW5nKG1pc3NpbmcpO1xuICAgIH1cblxuICAgIGJ1aWxkZXIuYWRkQXJ0aWZhY3Qoc3RhY2suc3RhY2tOYW1lLCB7XG4gICAgICB0eXBlOiBjeHNjaGVtYS5BcnRpZmFjdFR5cGUuQVdTX0NMT1VERk9STUFUSU9OX1NUQUNLLFxuICAgICAgZW52aXJvbm1lbnQ6IHN0YWNrLmVudiB8fCAnYXdzOi8vMTIzNDUvaGVyZScsXG5cbiAgICAgIGRlcGVuZGVuY2llczogc3RhY2suZGVwZW5kcyxcbiAgICAgIG1ldGFkYXRhLFxuICAgICAgcHJvcGVydGllczoge1xuICAgICAgICAuLi5zdGFjay5wcm9wZXJ0aWVzLFxuICAgICAgICB0ZW1wbGF0ZUZpbGUsXG4gICAgICAgIHRlcm1pbmF0aW9uUHJvdGVjdGlvbjogc3RhY2sudGVybWluYXRpb25Qcm90ZWN0aW9uLFxuICAgICAgfSxcbiAgICB9KTtcbiAgfVxuXG4gIHJldHVybiBidWlsZGVyLmJ1aWxkQXNzZW1ibHkoKTtcbn1cblxuLyoqXG4gKiBUcmFuc2Zvcm0gc3RhY2sgdGFncyBmcm9tIGhvdyB0aGV5IGFyZSBkZWNhbHJlZCBpbiBzb3VyY2UgY29kZSAobG93ZXIgY2FzZWQpXG4gKiB0byBob3cgdGhleSBhcmUgc3RvcmVkIG9uIGRpc2sgKHVwcGVyIGNhc2VkKS4gSW4gcmVhbCBzeW50aGVzaXMgdGhpcyBpcyBkb25lXG4gKiBieSBhIHNwZWNpYWwgdGFncyBmb3JtYXR0ZXIuXG4gKlxuICogQHNlZSBAYXdzLWNkay9jb3JlL2xpYi9zdGFjay50c1xuICovXG5mdW5jdGlvbiBwYXRjaFN0YWNrVGFncyhtZXRhZGF0YTogeyBbcGF0aDogc3RyaW5nXTogY3hzY2hlbWEuTWV0YWRhdGFFbnRyeVtdIH0pOiB7IFtwYXRoOiBzdHJpbmddOiBjeHNjaGVtYS5NZXRhZGF0YUVudHJ5W10gfSB7XG5cbiAgY29uc3QgY2xvbmVkID0gY2xvbmUobWV0YWRhdGEpIGFzIHsgW3BhdGg6IHN0cmluZ106IGN4c2NoZW1hLk1ldGFkYXRhRW50cnlbXSB9O1xuXG4gIGZvciAoY29uc3QgbWV0YWRhdGFFbnRyaWVzIG9mIE9iamVjdC52YWx1ZXMoY2xvbmVkKSkge1xuICAgIGZvciAoY29uc3QgbWV0YWRhdGFFbnRyeSBvZiBtZXRhZGF0YUVudHJpZXMpIHtcbiAgICAgIGlmIChtZXRhZGF0YUVudHJ5LnR5cGUgPT09IGN4c2NoZW1hLkFydGlmYWN0TWV0YWRhdGFFbnRyeVR5cGUuU1RBQ0tfVEFHUyAmJiBtZXRhZGF0YUVudHJ5LmRhdGEpIHtcblxuICAgICAgICBjb25zdCBtZXRhZGF0YUFueSA9IG1ldGFkYXRhRW50cnkgYXMgYW55O1xuXG4gICAgICAgIG1ldGFkYXRhQW55LmRhdGEgPSBtZXRhZGF0YUFueS5kYXRhLm1hcCgodDogYW55KSA9PiB7XG4gICAgICAgICAgcmV0dXJuIHsgS2V5OiB0LmtleSwgVmFsdWU6IHQudmFsdWUgfTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBjbG9uZWQ7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB0ZXN0U3RhY2soc3RhY2s6IFRlc3RTdGFja0FydGlmYWN0KSB7XG4gIGNvbnN0IGFzc2VtYmx5ID0gdGVzdEFzc2VtYmx5KHsgc3RhY2tzOiBbc3RhY2tdIH0pO1xuICByZXR1cm4gYXNzZW1ibHkuZ2V0U3RhY2tCeU5hbWUoc3RhY2suc3RhY2tOYW1lKTtcbn1cblxuLyoqXG4gKiBSZXR1cm4gYSBtb2NrZWQgaW5zdGFuY2Ugb2YgYSBjbGFzcywgZ2l2ZW4gaXRzIGNvbnN0cnVjdG9yXG4gKlxuICogSSBkb24ndCB1bmRlcnN0YW5kIHdoeSBqZXN0IGRvZXNuJ3QgcHJvdmlkZSB0aGlzIGJ5IGRlZmF1bHQsXG4gKiBidXQgdGhlcmUgeW91IGdvLlxuICpcbiAqIEZJWE1FOiBDdXJyZW50bHkgdmVyeSBsaW1pdGVkLiBEb2Vzbid0IHN1cHBvcnQgaW5oZXJpdGFuY2UsIGdldHRlcnMgb3JcbiAqIGF1dG9tYXRpYyBkZXRlY3Rpb24gb2YgcHJvcGVydGllcyAoYXMgdGhvc2UgZXhpc3Qgb24gaW5zdGFuY2VzLCBub3RcbiAqIGNsYXNzZXMpLlxuICovXG5leHBvcnQgZnVuY3Rpb24gaW5zdGFuY2VNb2NrRnJvbTxBPihjdHI6IG5ldyAoLi4uYXJnczogYW55W10pID0+IEEpOiBqZXN0Lk1vY2tlZDxBPiB7XG4gIGNvbnN0IHJldDogYW55ID0ge307XG4gIGZvciAoY29uc3QgbWV0aG9kTmFtZSBvZiBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhjdHIucHJvdG90eXBlKSkge1xuICAgIHJldFttZXRob2ROYW1lXSA9IGplc3QuZm4oKTtcbiAgfVxuICByZXR1cm4gcmV0O1xufVxuXG4vKipcbiAqIFJ1biBhbiBhc3luYyBibG9jayB3aXRoIGEgY2xhc3MgKGNvbnN0cnVjdG9yKSByZXBsYWNlZCB3aXRoIGEgbW9ja1xuICpcbiAqIFRoZSBjbGFzcyBjb25zdHJ1Y3RvciB3aWxsIGJlIHJlcGxhY2VkIHdpdGggYSBjb25zdHJ1Y3RvciB0aGF0IHJldHVybnNcbiAqIGEgc2luZ2xldG9uLCBhbmQgdGhlIHNpbmdsZXRvbiB3aWxsIGJlIHBhc3NlZCB0byB0aGUgYmxvY2sgc28gdGhhdCBpdHNcbiAqIG1ldGhvZHMgY2FuIGJlIG1vY2tlZCBpbmRpdmlkdWFsbHkuXG4gKlxuICogVXNlcyBgaW5zdGFuY2VNb2NrRnJvbWAgc28gaXMgc3ViamVjdCB0byB0aGUgc2FtZSBsaW1pdGF0aW9ucyB0aGF0IGhvbGRcbiAqIGZvciB0aGF0IGZ1bmN0aW9uLlxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gd2l0aE1vY2tlZENsYXNzU2luZ2xldG9uPEEgZXh0ZW5kcyBvYmplY3QsIEsgZXh0ZW5kcyBrZXlvZiBBLCBCPihcbiAgb2JqOiBBLFxuICBrZXk6IEssXG4gIGNiOiAobW9jazogQVtLXSBleHRlbmRzIGplc3QuQ29uc3RydWN0YWJsZSA/IGplc3QuTW9ja2VkPEluc3RhbmNlVHlwZTxBW0tdPj4gOiBuZXZlcikgPT4gUHJvbWlzZTxCPixcbik6IFByb21pc2U8Qj4ge1xuXG4gIGNvbnN0IG9yaWdpbmFsID0gb2JqW2tleV07XG4gIHRyeSB7XG4gICAgY29uc3QgbW9jayA9IGluc3RhbmNlTW9ja0Zyb20ob3JpZ2luYWwgYXMgYW55KTtcbiAgICBvYmpba2V5XSA9IGplc3QuZm4oKS5tb2NrUmV0dXJuVmFsdWUobW9jaykgYXMgYW55O1xuICAgIGNvbnN0IHJldCA9IGF3YWl0IGNiKG1vY2sgYXMgYW55KTtcbiAgICByZXR1cm4gcmV0O1xuICB9IGZpbmFsbHkge1xuICAgIG9ialtrZXldID0gb3JpZ2luYWw7XG4gIH1cbn0iXX0=