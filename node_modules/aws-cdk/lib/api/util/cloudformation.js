"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.StackParameters = exports.TemplateParameters = exports.stabilizeStack = exports.waitForStackDeploy = exports.waitForStackDelete = exports.changeSetHasNoChanges = exports.waitForChangeSet = exports.CloudFormationStack = void 0;
const logging_1 = require("../../logging");
const serialize_1 = require("../../serialize");
const stack_status_1 = require("./cloudformation/stack-status");
/**
 * Represents an (existing) Stack in CloudFormation
 *
 * Bundle and cache some information that we need during deployment (so we don't have to make
 * repeated calls to CloudFormation).
 */
class CloudFormationStack {
    constructor(cfn, stackName, stack) {
        this.cfn = cfn;
        this.stackName = stackName;
        this.stack = stack;
    }
    static async lookup(cfn, stackName) {
        try {
            const response = await cfn.describeStacks({ StackName: stackName }).promise();
            return new CloudFormationStack(cfn, stackName, response.Stacks && response.Stacks[0]);
        }
        catch (e) {
            if (e.code === 'ValidationError' && e.message === `Stack with id ${stackName} does not exist`) {
                return new CloudFormationStack(cfn, stackName, undefined);
            }
            throw e;
        }
    }
    /**
     * Return a copy of the given stack that does not exist
     *
     * It's a little silly that it needs arguments to do that, but there we go.
     */
    static doesNotExist(cfn, stackName) {
        return new CloudFormationStack(cfn, stackName);
    }
    /**
     * From static information (for testing)
     */
    static fromStaticInformation(cfn, stackName, stack) {
        return new CloudFormationStack(cfn, stackName, stack);
    }
    /**
     * Retrieve the stack's deployed template
     *
     * Cached, so will only be retrieved once. Will return an empty
     * structure if the stack does not exist.
     */
    async template() {
        if (!this.exists) {
            return {};
        }
        if (this._template === undefined) {
            const response = await this.cfn.getTemplate({ StackName: this.stackName, TemplateStage: 'Original' }).promise();
            this._template = (response.TemplateBody && serialize_1.deserializeStructure(response.TemplateBody)) || {};
        }
        return this._template;
    }
    /**
     * Whether the stack exists
     */
    get exists() {
        return this.stack !== undefined;
    }
    /**
     * The stack's ID
     *
     * Throws if the stack doesn't exist.
     */
    get stackId() {
        this.assertExists();
        return this.stack.StackId;
    }
    /**
     * The stack's current outputs
     *
     * Empty object if the stack doesn't exist
     */
    get outputs() {
        if (!this.exists) {
            return {};
        }
        const result = {};
        (this.stack.Outputs || []).forEach(output => {
            result[output.OutputKey] = output.OutputValue;
        });
        return result;
    }
    /**
     * The stack's status
     *
     * Special status NOT_FOUND if the stack does not exist.
     */
    get stackStatus() {
        if (!this.exists) {
            return new stack_status_1.StackStatus('NOT_FOUND', 'Stack not found during lookup');
        }
        return stack_status_1.StackStatus.fromStackDescription(this.stack);
    }
    /**
     * The stack's current tags
     *
     * Empty list of the stack does not exist
     */
    get tags() {
        var _a;
        return ((_a = this.stack) === null || _a === void 0 ? void 0 : _a.Tags) || [];
    }
    /**
     * Return the names of all current parameters to the stack
     *
     * Empty list if the stack does not exist.
     */
    get parameterNames() {
        return Object.keys(this.parameters);
    }
    /**
     * Return the names and values of all current parameters to the stack
     *
     * Empty object if the stack does not exist.
     */
    get parameters() {
        var _a;
        if (!this.exists) {
            return {};
        }
        const ret = {};
        for (const param of (_a = this.stack.Parameters) !== null && _a !== void 0 ? _a : []) {
            ret[param.ParameterKey] = param.ParameterValue;
        }
        return ret;
    }
    /**
     * Return the termination protection of the stack
     */
    get terminationProtection() {
        var _a;
        return (_a = this.stack) === null || _a === void 0 ? void 0 : _a.EnableTerminationProtection;
    }
    assertExists() {
        if (!this.exists) {
            throw new Error(`No stack named '${this.stackName}'`);
        }
    }
}
exports.CloudFormationStack = CloudFormationStack;
/**
 * Describe a changeset in CloudFormation, regardless of its current state.
 *
 * @param cfn       a CloudFormation client
 * @param stackName   the name of the Stack the ChangeSet belongs to
 * @param changeSetName the name of the ChangeSet
 *
 * @returns       CloudFormation information about the ChangeSet
 */
async function describeChangeSet(cfn, stackName, changeSetName) {
    const response = await cfn.describeChangeSet({ StackName: stackName, ChangeSetName: changeSetName }).promise();
    return response;
}
/**
 * Waits for a function to return non-+undefined+ before returning.
 *
 * @param valueProvider a function that will return a value that is not +undefined+ once the wait should be over
 * @param timeout     the time to wait between two calls to +valueProvider+
 *
 * @returns       the value that was returned by +valueProvider+
 */
async function waitFor(valueProvider, timeout = 5000) {
    while (true) {
        const result = await valueProvider();
        if (result === null) {
            return undefined;
        }
        else if (result !== undefined) {
            return result;
        }
        await new Promise(cb => setTimeout(cb, timeout));
    }
}
/**
 * Waits for a ChangeSet to be available for triggering a StackUpdate.
 *
 * Will return a changeset that is either ready to be executed or has no changes.
 * Will throw in other cases.
 *
 * @param cfn       a CloudFormation client
 * @param stackName   the name of the Stack that the ChangeSet belongs to
 * @param changeSetName the name of the ChangeSet
 *
 * @returns       the CloudFormation description of the ChangeSet
 */
// eslint-disable-next-line max-len
async function waitForChangeSet(cfn, stackName, changeSetName) {
    logging_1.debug('Waiting for changeset %s on stack %s to finish creating...', changeSetName, stackName);
    const ret = await waitFor(async () => {
        const description = await describeChangeSet(cfn, stackName, changeSetName);
        // The following doesn't use a switch because tsc will not allow fall-through, UNLESS it is allows
        // EVERYWHERE that uses this library directly or indirectly, which is undesirable.
        if (description.Status === 'CREATE_PENDING' || description.Status === 'CREATE_IN_PROGRESS') {
            logging_1.debug('Changeset %s on stack %s is still creating', changeSetName, stackName);
            return undefined;
        }
        if (description.Status === 'CREATE_COMPLETE' || changeSetHasNoChanges(description)) {
            return description;
        }
        // eslint-disable-next-line max-len
        throw new Error(`Failed to create ChangeSet ${changeSetName} on ${stackName}: ${description.Status || 'NO_STATUS'}, ${description.StatusReason || 'no reason provided'}`);
    });
    if (!ret) {
        throw new Error('Change set took too long to be created; aborting');
    }
    return ret;
}
exports.waitForChangeSet = waitForChangeSet;
/**
 * Return true if the given change set has no changes
 *
 * This must be determined from the status, not the 'Changes' array on the
 * object; the latter can be empty because no resources were changed, but if
 * there are changes to Outputs, the change set can still be executed.
 */
function changeSetHasNoChanges(description) {
    return description.Status === 'FAILED'
        && description.StatusReason
        && description.StatusReason.startsWith('The submitted information didn\'t contain changes.');
}
exports.changeSetHasNoChanges = changeSetHasNoChanges;
/**
 * Waits for a CloudFormation stack to stabilize in a complete/available state
 * after a delete operation is issued.
 *
 * Fails if the stack is in a FAILED state. Will not fail if the stack was
 * already deleted.
 *
 * @param cfn        a CloudFormation client
 * @param stackName      the name of the stack to wait for after a delete
 *
 * @returns     the CloudFormation description of the stabilized stack after the delete attempt
 */
async function waitForStackDelete(cfn, stackName) {
    const stack = await stabilizeStack(cfn, stackName);
    if (!stack) {
        return undefined;
    }
    const status = stack.stackStatus;
    if (status.isFailure) {
        throw new Error(`The stack named ${stackName} is in a failed state. You may need to delete it from the AWS console : ${status}`);
    }
    else if (status.isDeleted) {
        return undefined;
    }
    return stack;
}
exports.waitForStackDelete = waitForStackDelete;
/**
 * Waits for a CloudFormation stack to stabilize in a complete/available state
 * after an update/create operation is issued.
 *
 * Fails if the stack is in a FAILED state, ROLLBACK state, or DELETED state.
 *
 * @param cfn        a CloudFormation client
 * @param stackName      the name of the stack to wait for after an update
 *
 * @returns     the CloudFormation description of the stabilized stack after the update attempt
 */
async function waitForStackDeploy(cfn, stackName) {
    const stack = await stabilizeStack(cfn, stackName);
    if (!stack) {
        return undefined;
    }
    const status = stack.stackStatus;
    if (status.isCreationFailure) {
        throw new Error(`The stack named ${stackName} failed creation, it may need to be manually deleted from the AWS console: ${status}`);
    }
    else if (!status.isDeploySuccess) {
        throw new Error(`The stack named ${stackName} failed to deploy: ${status}`);
    }
    return stack;
}
exports.waitForStackDeploy = waitForStackDeploy;
/**
 * Wait for a stack to become stable (no longer _IN_PROGRESS), returning it
 */
async function stabilizeStack(cfn, stackName) {
    logging_1.debug('Waiting for stack %s to finish creating or updating...', stackName);
    return waitFor(async () => {
        const stack = await CloudFormationStack.lookup(cfn, stackName);
        if (!stack.exists) {
            logging_1.debug('Stack %s does not exist', stackName);
            return null;
        }
        const status = stack.stackStatus;
        if (status.isInProgress) {
            logging_1.debug('Stack %s has an ongoing operation in progress and is not stable (%s)', stackName, status);
            return undefined;
        }
        return stack;
    });
}
exports.stabilizeStack = stabilizeStack;
class TemplateParameters {
    constructor(params) {
        this.params = params;
    }
    static fromTemplate(template) {
        return new TemplateParameters(template.Parameters || {});
    }
    /**
     * Calculate stack parameters to pass from the given desired parameter values
     *
     * Will throw if parameters without a Default value or a Previous value are not
     * supplied.
     */
    toStackParameters(updates) {
        return new StackParameters(this.params, updates);
    }
    /**
     * From the template, the given desired values and the current values, calculate the changes to the stack parameters
     *
     * Will take into account parameters already set on the template (will emit
     * 'UsePreviousValue: true' for those unless the value is changed), and will
     * throw if parameters without a Default value or a Previous value are not
     * supplied.
     */
    diff(updates, previousValues) {
        return new StackParameters(this.params, updates, previousValues);
    }
}
exports.TemplateParameters = TemplateParameters;
class StackParameters {
    constructor(params, updates, previousValues = {}) {
        this.params = params;
        /**
         * The CloudFormation parameters to pass to the CreateStack or UpdateStack API
         */
        this.apiParameters = [];
        this._changes = false;
        const missingRequired = new Array();
        for (const [key, param] of Object.entries(this.params)) {
            // If any of the parameters are SSM parameters, they will always lead to a change
            if (param.Type.startsWith('AWS::SSM::Parameter::')) {
                this._changes = true;
            }
            if (key in updates && updates[key]) {
                this.apiParameters.push({ ParameterKey: key, ParameterValue: updates[key] });
                // If the updated value is different than the current value, this will lead to a change
                if (!(key in previousValues) || updates[key] !== previousValues[key]) {
                    this._changes = true;
                }
            }
            else if (key in previousValues) {
                this.apiParameters.push({ ParameterKey: key, UsePreviousValue: true });
            }
            else if (param.Default === undefined) {
                missingRequired.push(key);
            }
        }
        if (missingRequired.length > 0) {
            throw new Error(`The following CloudFormation Parameters are missing a value: ${missingRequired.join(', ')}`);
        }
        // Just append all supplied overrides that aren't really expected (this
        // will fail CFN but maybe people made typos that they want to be notified
        // of)
        const unknownParam = ([key, _]) => this.params[key] === undefined;
        const hasValue = ([_, value]) => !!value;
        for (const [key, value] of Object.entries(updates).filter(unknownParam).filter(hasValue)) {
            this.apiParameters.push({ ParameterKey: key, ParameterValue: value });
        }
    }
    /**
     * Whether this set of parameter updates will change the actual stack values
     */
    get changed() {
        return this._changes;
    }
}
exports.StackParameters = StackParameters;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY2xvdWRmb3JtYXRpb24uanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJjbG91ZGZvcm1hdGlvbi50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7QUFDQSwyQ0FBc0M7QUFDdEMsK0NBQXVEO0FBQ3ZELGdFQUE0RDtBQWE1RDs7Ozs7R0FLRztBQUNILE1BQWEsbUJBQW1CO0lBK0I5QixZQUF1QyxHQUFtQixFQUFrQixTQUFpQixFQUFtQixLQUE0QjtRQUFyRyxRQUFHLEdBQUgsR0FBRyxDQUFnQjtRQUFrQixjQUFTLEdBQVQsU0FBUyxDQUFRO1FBQW1CLFVBQUssR0FBTCxLQUFLLENBQXVCO0lBQzVJLENBQUM7SUEvQk0sTUFBTSxDQUFDLEtBQUssQ0FBQyxNQUFNLENBQUMsR0FBbUIsRUFBRSxTQUFpQjtRQUMvRCxJQUFJO1lBQ0YsTUFBTSxRQUFRLEdBQUcsTUFBTSxHQUFHLENBQUMsY0FBYyxDQUFDLEVBQUUsU0FBUyxFQUFFLFNBQVMsRUFBRSxDQUFDLENBQUMsT0FBTyxFQUFFLENBQUM7WUFDOUUsT0FBTyxJQUFJLG1CQUFtQixDQUFDLEdBQUcsRUFBRSxTQUFTLEVBQUUsUUFBUSxDQUFDLE1BQU0sSUFBSSxRQUFRLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7U0FDdkY7UUFBQyxPQUFPLENBQUMsRUFBRTtZQUNWLElBQUksQ0FBQyxDQUFDLElBQUksS0FBSyxpQkFBaUIsSUFBSSxDQUFDLENBQUMsT0FBTyxLQUFLLGlCQUFpQixTQUFTLGlCQUFpQixFQUFFO2dCQUM3RixPQUFPLElBQUksbUJBQW1CLENBQUMsR0FBRyxFQUFFLFNBQVMsRUFBRSxTQUFTLENBQUMsQ0FBQzthQUMzRDtZQUNELE1BQU0sQ0FBQyxDQUFDO1NBQ1Q7SUFDSCxDQUFDO0lBRUQ7Ozs7T0FJRztJQUNJLE1BQU0sQ0FBQyxZQUFZLENBQUMsR0FBbUIsRUFBRSxTQUFpQjtRQUMvRCxPQUFPLElBQUksbUJBQW1CLENBQUMsR0FBRyxFQUFFLFNBQVMs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SSxDQUFDLEdBQUcsQ0FBQyxDQUFDO2FBQzNCO1NBQ0Y7UUFFRCxJQUFJLGVBQWUsQ0FBQyxNQUFNLEdBQUcsQ0FBQyxFQUFFO1lBQzlCLE1BQU0sSUFBSSxLQUFLLENBQUMsZ0VBQWdFLGVBQWUsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLEVBQUUsQ0FBQyxDQUFDO1NBQy9HO1FBRUQsdUVBQXVFO1FBQ3ZFLDBFQUEwRTtRQUMxRSxNQUFNO1FBQ04sTUFBTSxZQUFZLEdBQUcsQ0FBQyxDQUFDLEdBQUcsRUFBRSxDQUFDLENBQWdCLEVBQUUsRUFBRSxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsR0FBRyxDQUFDLEtBQUssU0FBUyxDQUFDO1FBQ2pGLE1BQU0sUUFBUSxHQUFHLENBQUMsQ0FBQyxDQUFDLEVBQUUsS0FBSyxDQUFnQixFQUFFLEVBQUUsQ0FBQyxDQUFDLENBQUMsS0FBSyxDQUFDO1FBQ3hELEtBQUssTUFBTSxDQUFDLEdBQUcsRUFBRSxLQUFLLENBQUMsSUFBSSxNQUFNLENBQUMsT0FBTyxDQUFDLE9BQU8sQ0FBQyxDQUFDLE1BQU0sQ0FBQyxZQUFZLENBQUMsQ0FBQyxNQUFNLENBQUMsUUFBUSxDQUFDLEVBQUU7WUFDeEYsSUFBSSxDQUFDLGFBQWEsQ0FBQyxJQUFJLENBQUMsRUFBRSxZQUFZLEVBQUUsR0FBRyxFQUFFLGNBQWMsRUFBRSxLQUFLLEVBQUUsQ0FBQyxDQUFDO1NBQ3ZFO0lBQ0gsQ0FBQztJQUVEOztPQUVHO0lBQ0gsSUFBVyxPQUFPO1FBQ2hCLE9BQU8sSUFBSSxDQUFDLFFBQVEsQ0FBQztJQUN2QixDQUFDO0NBQ0Y7QUF2REQsMENBdURDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQ2xvdWRGb3JtYXRpb24gfSBmcm9tICdhd3Mtc2RrJztcbmltcG9ydCB7IGRlYnVnIH0gZnJvbSAnLi4vLi4vbG9nZ2luZyc7XG5pbXBvcnQgeyBkZXNlcmlhbGl6ZVN0cnVjdHVyZSB9IGZyb20gJy4uLy4uL3NlcmlhbGl6ZSc7XG5pbXBvcnQgeyBTdGFja1N0YXR1cyB9IGZyb20gJy4vY2xvdWRmb3JtYXRpb24vc3RhY2stc3RhdHVzJztcblxuZXhwb3J0IHR5cGUgVGVtcGxhdGUgPSB7XG4gIFBhcmFtZXRlcnM/OiBSZWNvcmQ8c3RyaW5nLCBUZW1wbGF0ZVBhcmFtZXRlcj47XG4gIFtrZXk6IHN0cmluZ106IGFueTtcbn07XG5cbmludGVyZmFjZSBUZW1wbGF0ZVBhcmFtZXRlciB7XG4gIFR5cGU6IHN0cmluZztcbiAgRGVmYXVsdD86IGFueTtcbiAgW2tleTogc3RyaW5nXTogYW55O1xufVxuXG4vKipcbiAqIFJlcHJlc2VudHMgYW4gKGV4aXN0aW5nKSBTdGFjayBpbiBDbG91ZEZvcm1hdGlvblxuICpcbiAqIEJ1bmRsZSBhbmQgY2FjaGUgc29tZSBpbmZvcm1hdGlvbiB0aGF0IHdlIG5lZWQgZHVyaW5nIGRlcGxveW1lbnQgKHNvIHdlIGRvbid0IGhhdmUgdG8gbWFrZVxuICogcmVwZWF0ZWQgY2FsbHMgdG8gQ2xvdWRGb3JtYXRpb24pLlxuICovXG5leHBvcnQgY2xhc3MgQ2xvdWRGb3JtYXRpb25TdGFjayB7XG4gIHB1YmxpYyBzdGF0aWMgYXN5bmMgbG9va3VwKGNmbjogQ2xvdWRGb3JtYXRpb24sIHN0YWNrTmFtZTogc3RyaW5nKTogUHJvbWlzZTxDbG91ZEZvcm1hdGlvblN0YWNrPiB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgY2ZuLmRlc2NyaWJlU3RhY2tzKHsgU3RhY2tOYW1lOiBzdGFja05hbWUgfSkucHJvbWlzZSgpO1xuICAgICAgcmV0dXJuIG5ldyBDbG91ZEZvcm1hdGlvblN0YWNrKGNmbiwgc3RhY2tOYW1lLCByZXNwb25zZS5TdGFja3MgJiYgcmVzcG9uc2UuU3RhY2tzWzBdKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBpZiAoZS5jb2RlID09PSAnVmFsaWRhdGlvbkVycm9yJyAmJiBlLm1lc3NhZ2UgPT09IGBTdGFjayB3aXRoIGlkICR7c3RhY2tOYW1lfSBkb2VzIG5vdCBleGlzdGApIHtcbiAgICAgICAgcmV0dXJuIG5ldyBDbG91ZEZvcm1hdGlvblN0YWNrKGNmbiwgc3RhY2tOYW1lLCB1bmRlZmluZWQpO1xuICAgICAgfVxuICAgICAgdGhyb3cgZTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIGEgY29weSBvZiB0aGUgZ2l2ZW4gc3RhY2sgdGhhdCBkb2VzIG5vdCBleGlzdFxuICAgKlxuICAgKiBJdCdzIGEgbGl0dGxlIHNpbGx5IHRoYXQgaXQgbmVlZHMgYXJndW1lbnRzIHRvIGRvIHRoYXQsIGJ1dCB0aGVyZSB3ZSBnby5cbiAgICovXG4gIHB1YmxpYyBzdGF0aWMgZG9lc05vdEV4aXN0KGNmbjogQ2xvdWRGb3JtYXRpb24sIHN0YWNrTmFtZTogc3RyaW5nKSB7XG4gICAgcmV0dXJuIG5ldyBDbG91ZEZvcm1hdGlvblN0YWNrKGNmbiwgc3RhY2tOYW1lKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBGcm9tIHN0YXRpYyBpbmZvcm1hdGlvbiAoZm9yIHRlc3RpbmcpXG4gICAqL1xuICBwdWJsaWMgc3RhdGljIGZyb21TdGF0aWNJbmZvcm1hdGlvbihjZm46IENsb3VkRm9ybWF0aW9uLCBzdGFja05hbWU6IHN0cmluZywgc3RhY2s6IENsb3VkRm9ybWF0aW9uLlN0YWNrKSB7XG4gICAgcmV0dXJuIG5ldyBDbG91ZEZvcm1hdGlvblN0YWNrKGNmbiwgc3RhY2tOYW1lLCBzdGFjayk7XG4gIH1cblxuICBwcml2YXRlIF90ZW1wbGF0ZTogYW55O1xuXG4gIHByb3RlY3RlZCBjb25zdHJ1Y3Rvcihwcml2YXRlIHJlYWRvbmx5IGNmbjogQ2xvdWRGb3JtYXRpb24sIHB1YmxpYyByZWFkb25seSBzdGFja05hbWU6IHN0cmluZywgcHJpdmF0ZSByZWFkb25seSBzdGFjaz86IENsb3VkRm9ybWF0aW9uLlN0YWNrKSB7XG4gIH1cblxuICAvKipcbiAgICogUmV0cmlldmUgdGhlIHN0YWNrJ3MgZGVwbG95ZWQgdGVtcGxhdGVcbiAgICpcbiAgICogQ2FjaGVkLCBzbyB3aWxsIG9ubHkgYmUgcmV0cmlldmVkIG9uY2UuIFdpbGwgcmV0dXJuIGFuIGVtcHR5XG4gICAqIHN0cnVjdHVyZSBpZiB0aGUgc3RhY2sgZG9lcyBub3QgZXhpc3QuXG4gICAqL1xuICBwdWJsaWMgYXN5bmMgdGVtcGxhdGUoKTogUHJvbWlzZTxUZW1wbGF0ZT4ge1xuICAgIGlmICghdGhpcy5leGlzdHMpIHtcbiAgICAgIHJldHVybiB7fTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5fdGVtcGxhdGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmNmbi5nZXRUZW1wbGF0ZSh7IFN0YWNrTmFtZTogdGhpcy5zdGFja05hbWUsIFRlbXBsYXRlU3RhZ2U6ICdPcmlnaW5hbCcgfSkucHJvbWlzZSgpO1xuICAgICAgdGhpcy5fdGVtcGxhdGUgPSAocmVzcG9uc2UuVGVtcGxhdGVCb2R5ICYmIGRlc2VyaWFsaXplU3RydWN0dXJlKHJlc3BvbnNlLlRlbXBsYXRlQm9keSkpIHx8IHt9O1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fdGVtcGxhdGU7XG4gIH1cblxuICAvKipcbiAgICogV2hldGhlciB0aGUgc3RhY2sgZXhpc3RzXG4gICAqL1xuICBwdWJsaWMgZ2V0IGV4aXN0cygpIHtcbiAgICByZXR1cm4gdGhpcy5zdGFjayAhPT0gdW5kZWZpbmVkO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSBzdGFjaydzIElEXG4gICAqXG4gICAqIFRocm93cyBpZiB0aGUgc3RhY2sgZG9lc24ndCBleGlzdC5cbiAgICovXG4gIHB1YmxpYyBnZXQgc3RhY2tJZCgpIHtcbiAgICB0aGlzLmFzc2VydEV4aXN0cygpO1xuICAgIHJldHVybiB0aGlzLnN0YWNrIS5TdGFja0lkITtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgc3RhY2sncyBjdXJyZW50IG91dHB1dHNcbiAgICpcbiAgICogRW1wdHkgb2JqZWN0IGlmIHRoZSBzdGFjayBkb2Vzbid0IGV4aXN0XG4gICAqL1xuICBwdWJsaWMgZ2V0IG91dHB1dHMoKTogUmVjb3JkPHN0cmluZywgc3RyaW5nPiB7XG4gICAgaWYgKCF0aGlzLmV4aXN0cykgeyByZXR1cm4ge307IH1cbiAgICBjb25zdCByZXN1bHQ6IHsgW25hbWU6IHN0cmluZ106IHN0cmluZyB9ID0ge307XG4gICAgKHRoaXMuc3RhY2shLk91dHB1dHMgfHwgW10pLmZvckVhY2gob3V0cHV0ID0+IHtcbiAgICAgIHJlc3VsdFtvdXRwdXQuT3V0cHV0S2V5IV0gPSBvdXRwdXQuT3V0cHV0VmFsdWUhO1xuICAgIH0pO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICAvKipcbiAgICogVGhlIHN0YWNrJ3Mgc3RhdHVzXG4gICAqXG4gICAqIFNwZWNpYWwgc3RhdHVzIE5PVF9GT1VORCBpZiB0aGUgc3RhY2sgZG9lcyBub3QgZXhpc3QuXG4gICAqL1xuICBwdWJsaWMgZ2V0IHN0YWNrU3RhdHVzKCk6IFN0YWNrU3RhdHVzIHtcbiAgICBpZiAoIXRoaXMuZXhpc3RzKSB7XG4gICAgICByZXR1cm4gbmV3IFN0YWNrU3RhdHVzKCdOT1RfRk9VTkQnLCAnU3RhY2sgbm90IGZvdW5kIGR1cmluZyBsb29rdXAnKTtcbiAgICB9XG4gICAgcmV0dXJuIFN0YWNrU3RhdHVzLmZyb21TdGFja0Rlc2NyaXB0aW9uKHRoaXMuc3RhY2shKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgc3RhY2sncyBjdXJyZW50IHRhZ3NcbiAgICpcbiAgICogRW1wdHkgbGlzdCBvZiB0aGUgc3RhY2sgZG9lcyBub3QgZXhpc3RcbiAgICovXG4gIHB1YmxpYyBnZXQgdGFncygpOiBDbG91ZEZvcm1hdGlvbi5UYWdzIHtcbiAgICByZXR1cm4gdGhpcy5zdGFjaz8uVGFncyB8fCBbXTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gdGhlIG5hbWVzIG9mIGFsbCBjdXJyZW50IHBhcmFtZXRlcnMgdG8gdGhlIHN0YWNrXG4gICAqXG4gICAqIEVtcHR5IGxpc3QgaWYgdGhlIHN0YWNrIGRvZXMgbm90IGV4aXN0LlxuICAgKi9cbiAgcHVibGljIGdldCBwYXJhbWV0ZXJOYW1lcygpOiBzdHJpbmdbXSB7XG4gICAgcmV0dXJuIE9iamVjdC5rZXlzKHRoaXMucGFyYW1ldGVycyk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIHRoZSBuYW1lcyBhbmQgdmFsdWVzIG9mIGFsbCBjdXJyZW50IHBhcmFtZXRlcnMgdG8gdGhlIHN0YWNrXG4gICAqXG4gICAqIEVtcHR5IG9iamVjdCBpZiB0aGUgc3RhY2sgZG9lcyBub3QgZXhpc3QuXG4gICAqL1xuICBwdWJsaWMgZ2V0IHBhcmFtZXRlcnMoKTogUmVjb3JkPHN0cmluZywgc3RyaW5nPiB7XG4gICAgaWYgKCF0aGlzLmV4aXN0cykgeyByZXR1cm4ge307IH1cbiAgICBjb25zdCByZXQ6IFJlY29yZDxzdHJpbmcsIHN0cmluZz4gPSB7fTtcbiAgICBmb3IgKGNvbnN0IHBhcmFtIG9mIHRoaXMuc3RhY2shLlBhcmFtZXRlcnMgPz8gW10pIHtcbiAgICAgIHJldFtwYXJhbS5QYXJhbWV0ZXJLZXkhXSA9IHBhcmFtLlBhcmFtZXRlclZhbHVlITtcbiAgICB9XG4gICAgcmV0dXJuIHJldDtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gdGhlIHRlcm1pbmF0aW9uIHByb3RlY3Rpb24gb2YgdGhlIHN0YWNrXG4gICAqL1xuICBwdWJsaWMgZ2V0IHRlcm1pbmF0aW9uUHJvdGVjdGlvbigpOiBib29sZWFuIHwgdW5kZWZpbmVkIHtcbiAgICByZXR1cm4gdGhpcy5zdGFjaz8uRW5hYmxlVGVybWluYXRpb25Qcm90ZWN0aW9uO1xuICB9XG5cbiAgcHJpdmF0ZSBhc3NlcnRFeGlzdHMoKSB7XG4gICAgaWYgKCF0aGlzLmV4aXN0cykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBObyBzdGFjayBuYW1lZCAnJHt0aGlzLnN0YWNrTmFtZX0nYCk7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogRGVzY3JpYmUgYSBjaGFuZ2VzZXQgaW4gQ2xvdWRGb3JtYXRpb24sIHJlZ2FyZGxlc3Mgb2YgaXRzIGN1cnJlbnQgc3RhdGUuXG4gKlxuICogQHBhcmFtIGNmbiAgICAgICBhIENsb3VkRm9ybWF0aW9uIGNsaWVudFxuICogQHBhcmFtIHN0YWNrTmFtZSAgIHRoZSBuYW1lIG9mIHRoZSBTdGFjayB0aGUgQ2hhbmdlU2V0IGJlbG9uZ3MgdG9cbiAqIEBwYXJhbSBjaGFuZ2VTZXROYW1lIHRoZSBuYW1lIG9mIHRoZSBDaGFuZ2VTZXRcbiAqXG4gKiBAcmV0dXJucyAgICAgICBDbG91ZEZvcm1hdGlvbiBpbmZvcm1hdGlvbiBhYm91dCB0aGUgQ2hhbmdlU2V0XG4gKi9cbmFzeW5jIGZ1bmN0aW9uIGRlc2NyaWJlQ2hhbmdlU2V0KGNmbjogQ2xvdWRGb3JtYXRpb24sIHN0YWNrTmFtZTogc3RyaW5nLCBjaGFuZ2VTZXROYW1lOiBzdHJpbmcpOiBQcm9taXNlPENsb3VkRm9ybWF0aW9uLkRlc2NyaWJlQ2hhbmdlU2V0T3V0cHV0PiB7XG4gIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgY2ZuLmRlc2NyaWJlQ2hhbmdlU2V0KHsgU3RhY2tOYW1lOiBzdGFja05hbWUsIENoYW5nZVNldE5hbWU6IGNoYW5nZVNldE5hbWUgfSkucHJvbWlzZSgpO1xuICByZXR1cm4gcmVzcG9uc2U7XG59XG5cbi8qKlxuICogV2FpdHMgZm9yIGEgZnVuY3Rpb24gdG8gcmV0dXJuIG5vbi0rdW5kZWZpbmVkKyBiZWZvcmUgcmV0dXJuaW5nLlxuICpcbiAqIEBwYXJhbSB2YWx1ZVByb3ZpZGVyIGEgZnVuY3Rpb24gdGhhdCB3aWxsIHJldHVybiBhIHZhbHVlIHRoYXQgaXMgbm90ICt1bmRlZmluZWQrIG9uY2UgdGhlIHdhaXQgc2hvdWxkIGJlIG92ZXJcbiAqIEBwYXJhbSB0aW1lb3V0ICAgICB0aGUgdGltZSB0byB3YWl0IGJldHdlZW4gdHdvIGNhbGxzIHRvICt2YWx1ZVByb3ZpZGVyK1xuICpcbiAqIEByZXR1cm5zICAgICAgIHRoZSB2YWx1ZSB0aGF0IHdhcyByZXR1cm5lZCBieSArdmFsdWVQcm92aWRlcitcbiAqL1xuYXN5bmMgZnVuY3Rpb24gd2FpdEZvcjxUPih2YWx1ZVByb3ZpZGVyOiAoKSA9PiBQcm9taXNlPFQgfCBudWxsIHwgdW5kZWZpbmVkPiwgdGltZW91dDogbnVtYmVyID0gNTAwMCk6IFByb21pc2U8VCB8IHVuZGVmaW5lZD4ge1xuICB3aGlsZSAodHJ1ZSkge1xuICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHZhbHVlUHJvdmlkZXIoKTtcbiAgICBpZiAocmVzdWx0ID09PSBudWxsKSB7XG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH0gZWxzZSBpZiAocmVzdWx0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIGF3YWl0IG5ldyBQcm9taXNlKGNiID0+IHNldFRpbWVvdXQoY2IsIHRpbWVvdXQpKTtcbiAgfVxufVxuXG4vKipcbiAqIFdhaXRzIGZvciBhIENoYW5nZVNldCB0byBiZSBhdmFpbGFibGUgZm9yIHRyaWdnZXJpbmcgYSBTdGFja1VwZGF0ZS5cbiAqXG4gKiBXaWxsIHJldHVybiBhIGNoYW5nZXNldCB0aGF0IGlzIGVpdGhlciByZWFkeSB0byBiZSBleGVjdXRlZCBvciBoYXMgbm8gY2hhbmdlcy5cbiAqIFdpbGwgdGhyb3cgaW4gb3RoZXIgY2FzZXMuXG4gKlxuICogQHBhcmFtIGNmbiAgICAgICBhIENsb3VkRm9ybWF0aW9uIGNsaWVudFxuICogQHBhcmFtIHN0YWNrTmFtZSAgIHRoZSBuYW1lIG9mIHRoZSBTdGFjayB0aGF0IHRoZSBDaGFuZ2VTZXQgYmVsb25ncyB0b1xuICogQHBhcmFtIGNoYW5nZVNldE5hbWUgdGhlIG5hbWUgb2YgdGhlIENoYW5nZVNldFxuICpcbiAqIEByZXR1cm5zICAgICAgIHRoZSBDbG91ZEZvcm1hdGlvbiBkZXNjcmlwdGlvbiBvZiB0aGUgQ2hhbmdlU2V0XG4gKi9cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBtYXgtbGVuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gd2FpdEZvckNoYW5nZVNldChjZm46IENsb3VkRm9ybWF0aW9uLCBzdGFja05hbWU6IHN0cmluZywgY2hhbmdlU2V0TmFtZTogc3RyaW5nKTogUHJvbWlzZTxDbG91ZEZvcm1hdGlvbi5EZXNjcmliZUNoYW5nZVNldE91dHB1dD4ge1xuICBkZWJ1ZygnV2FpdGluZyBmb3IgY2hhbmdlc2V0ICVzIG9uIHN0YWNrICVzIHRvIGZpbmlzaCBjcmVhdGluZy4uLicsIGNoYW5nZVNldE5hbWUsIHN0YWNrTmFtZSk7XG4gIGNvbnN0IHJldCA9IGF3YWl0IHdhaXRGb3IoYXN5bmMgKCkgPT4ge1xuICAgIGNvbnN0IGRlc2NyaXB0aW9uID0gYXdhaXQgZGVzY3JpYmVDaGFuZ2VTZXQoY2ZuLCBzdGFja05hbWUsIGNoYW5nZVNldE5hbWUpO1xuICAgIC8vIFRoZSBmb2xsb3dpbmcgZG9lc24ndCB1c2UgYSBzd2l0Y2ggYmVjYXVzZSB0c2Mgd2lsbCBub3QgYWxsb3cgZmFsbC10aHJvdWdoLCBVTkxFU1MgaXQgaXMgYWxsb3dzXG4gICAgLy8gRVZFUllXSEVSRSB0aGF0IHVzZXMgdGhpcyBsaWJyYXJ5IGRpcmVjdGx5IG9yIGluZGlyZWN0bHksIHdoaWNoIGlzIHVuZGVzaXJhYmxlLlxuICAgIGlmIChkZXNjcmlwdGlvbi5TdGF0dXMgPT09ICdDUkVBVEVfUEVORElORycgfHwgZGVzY3JpcHRpb24uU3RhdHVzID09PSAnQ1JFQVRFX0lOX1BST0dSRVNTJykge1xuICAgICAgZGVidWcoJ0NoYW5nZXNldCAlcyBvbiBzdGFjayAlcyBpcyBzdGlsbCBjcmVhdGluZycsIGNoYW5nZVNldE5hbWUsIHN0YWNrTmFtZSk7XG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIGlmIChkZXNjcmlwdGlvbi5TdGF0dXMgPT09ICdDUkVBVEVfQ09NUExFVEUnIHx8IGNoYW5nZVNldEhhc05vQ2hhbmdlcyhkZXNjcmlwdGlvbikpIHtcbiAgICAgIHJldHVybiBkZXNjcmlwdGlvbjtcbiAgICB9XG5cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbWF4LWxlblxuICAgIHRocm93IG5ldyBFcnJvcihgRmFpbGVkIHRvIGNyZWF0ZSBDaGFuZ2VTZXQgJHtjaGFuZ2VTZXROYW1lfSBvbiAke3N0YWNrTmFtZX06ICR7ZGVzY3JpcHRpb24uU3RhdHVzIHx8ICdOT19TVEFUVVMnfSwgJHtkZXNjcmlwdGlvbi5TdGF0dXNSZWFzb24gfHwgJ25vIHJlYXNvbiBwcm92aWRlZCd9YCk7XG4gIH0pO1xuXG4gIGlmICghcmV0KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdDaGFuZ2Ugc2V0IHRvb2sgdG9vIGxvbmcgdG8gYmUgY3JlYXRlZDsgYWJvcnRpbmcnKTtcbiAgfVxuXG4gIHJldHVybiByZXQ7XG59XG5cbi8qKlxuICogUmV0dXJuIHRydWUgaWYgdGhlIGdpdmVuIGNoYW5nZSBzZXQgaGFzIG5vIGNoYW5nZXNcbiAqXG4gKiBUaGlzIG11c3QgYmUgZGV0ZXJtaW5lZCBmcm9tIHRoZSBzdGF0dXMsIG5vdCB0aGUgJ0NoYW5nZXMnIGFycmF5IG9uIHRoZVxuICogb2JqZWN0OyB0aGUgbGF0dGVyIGNhbiBiZSBlbXB0eSBiZWNhdXNlIG5vIHJlc291cmNlcyB3ZXJlIGNoYW5nZWQsIGJ1dCBpZlxuICogdGhlcmUgYXJlIGNoYW5nZXMgdG8gT3V0cHV0cywgdGhlIGNoYW5nZSBzZXQgY2FuIHN0aWxsIGJlIGV4ZWN1dGVkLlxuICovXG5leHBvcnQgZnVuY3Rpb24gY2hhbmdlU2V0SGFzTm9DaGFuZ2VzKGRlc2NyaXB0aW9uOiBDbG91ZEZvcm1hdGlvbi5EZXNjcmliZUNoYW5nZVNldE91dHB1dCkge1xuICByZXR1cm4gZGVzY3JpcHRpb24uU3RhdHVzID09PSAnRkFJTEVEJ1xuICAgICAgJiYgZGVzY3JpcHRpb24uU3RhdHVzUmVhc29uXG4gICAgICAmJiBkZXNjcmlwdGlvbi5TdGF0dXNSZWFzb24uc3RhcnRzV2l0aCgnVGhlIHN1Ym1pdHRlZCBpbmZvcm1hdGlvbiBkaWRuXFwndCBjb250YWluIGNoYW5nZXMuJyk7XG59XG5cbi8qKlxuICogV2FpdHMgZm9yIGEgQ2xvdWRGb3JtYXRpb24gc3RhY2sgdG8gc3RhYmlsaXplIGluIGEgY29tcGxldGUvYXZhaWxhYmxlIHN0YXRlXG4gKiBhZnRlciBhIGRlbGV0ZSBvcGVyYXRpb24gaXMgaXNzdWVkLlxuICpcbiAqIEZhaWxzIGlmIHRoZSBzdGFjayBpcyBpbiBhIEZBSUxFRCBzdGF0ZS4gV2lsbCBub3QgZmFpbCBpZiB0aGUgc3RhY2sgd2FzXG4gKiBhbHJlYWR5IGRlbGV0ZWQuXG4gKlxuICogQHBhcmFtIGNmbiAgICAgICAgYSBDbG91ZEZvcm1hdGlvbiBjbGllbnRcbiAqIEBwYXJhbSBzdGFja05hbWUgICAgICB0aGUgbmFtZSBvZiB0aGUgc3RhY2sgdG8gd2FpdCBmb3IgYWZ0ZXIgYSBkZWxldGVcbiAqXG4gKiBAcmV0dXJucyAgICAgdGhlIENsb3VkRm9ybWF0aW9uIGRlc2NyaXB0aW9uIG9mIHRoZSBzdGFiaWxpemVkIHN0YWNrIGFmdGVyIHRoZSBkZWxldGUgYXR0ZW1wdFxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gd2FpdEZvclN0YWNrRGVsZXRlKFxuICBjZm46IENsb3VkRm9ybWF0aW9uLFxuICBzdGFja05hbWU6IHN0cmluZyk6IFByb21pc2U8Q2xvdWRGb3JtYXRpb25TdGFjayB8IHVuZGVmaW5lZD4ge1xuXG4gIGNvbnN0IHN0YWNrID0gYXdhaXQgc3RhYmlsaXplU3RhY2soY2ZuLCBzdGFja05hbWUpO1xuICBpZiAoIXN0YWNrKSB7IHJldHVybiB1bmRlZmluZWQ7IH1cblxuICBjb25zdCBzdGF0dXMgPSBzdGFjay5zdGFja1N0YXR1cztcbiAgaWYgKHN0YXR1cy5pc0ZhaWx1cmUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYFRoZSBzdGFjayBuYW1lZCAke3N0YWNrTmFtZX0gaXMgaW4gYSBmYWlsZWQgc3RhdGUuIFlvdSBtYXkgbmVlZCB0byBkZWxldGUgaXQgZnJvbSB0aGUgQVdTIGNvbnNvbGUgOiAke3N0YXR1c31gKTtcbiAgfSBlbHNlIGlmIChzdGF0dXMuaXNEZWxldGVkKSB7XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxuICByZXR1cm4gc3RhY2s7XG59XG5cbi8qKlxuICogV2FpdHMgZm9yIGEgQ2xvdWRGb3JtYXRpb24gc3RhY2sgdG8gc3RhYmlsaXplIGluIGEgY29tcGxldGUvYXZhaWxhYmxlIHN0YXRlXG4gKiBhZnRlciBhbiB1cGRhdGUvY3JlYXRlIG9wZXJhdGlvbiBpcyBpc3N1ZWQuXG4gKlxuICogRmFpbHMgaWYgdGhlIHN0YWNrIGlzIGluIGEgRkFJTEVEIHN0YXRlLCBST0xMQkFDSyBzdGF0ZSwgb3IgREVMRVRFRCBzdGF0ZS5cbiAqXG4gKiBAcGFyYW0gY2ZuICAgICAgICBhIENsb3VkRm9ybWF0aW9uIGNsaWVudFxuICogQHBhcmFtIHN0YWNrTmFtZSAgICAgIHRoZSBuYW1lIG9mIHRoZSBzdGFjayB0byB3YWl0IGZvciBhZnRlciBhbiB1cGRhdGVcbiAqXG4gKiBAcmV0dXJucyAgICAgdGhlIENsb3VkRm9ybWF0aW9uIGRlc2NyaXB0aW9uIG9mIHRoZSBzdGFiaWxpemVkIHN0YWNrIGFmdGVyIHRoZSB1cGRhdGUgYXR0ZW1wdFxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gd2FpdEZvclN0YWNrRGVwbG95KFxuICBjZm46IENsb3VkRm9ybWF0aW9uLFxuICBzdGFja05hbWU6IHN0cmluZyk6IFByb21pc2U8Q2xvdWRGb3JtYXRpb25TdGFjayB8IHVuZGVmaW5lZD4ge1xuXG4gIGNvbnN0IHN0YWNrID0gYXdhaXQgc3RhYmlsaXplU3RhY2soY2ZuLCBzdGFja05hbWUpO1xuICBpZiAoIXN0YWNrKSB7IHJldHVybiB1bmRlZmluZWQ7IH1cblxuICBjb25zdCBzdGF0dXMgPSBzdGFjay5zdGFja1N0YXR1cztcblxuICBpZiAoc3RhdHVzLmlzQ3JlYXRpb25GYWlsdXJlKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBUaGUgc3RhY2sgbmFtZWQgJHtzdGFja05hbWV9IGZhaWxlZCBjcmVhdGlvbiwgaXQgbWF5IG5lZWQgdG8gYmUgbWFudWFsbHkgZGVsZXRlZCBmcm9tIHRoZSBBV1MgY29uc29sZTogJHtzdGF0dXN9YCk7XG4gIH0gZWxzZSBpZiAoIXN0YXR1cy5pc0RlcGxveVN1Y2Nlc3MpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYFRoZSBzdGFjayBuYW1lZCAke3N0YWNrTmFtZX0gZmFpbGVkIHRvIGRlcGxveTogJHtzdGF0dXN9YCk7XG4gIH1cblxuICByZXR1cm4gc3RhY2s7XG59XG5cbi8qKlxuICogV2FpdCBmb3IgYSBzdGFjayB0byBiZWNvbWUgc3RhYmxlIChubyBsb25nZXIgX0lOX1BST0dSRVNTKSwgcmV0dXJuaW5nIGl0XG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBzdGFiaWxpemVTdGFjayhjZm46IENsb3VkRm9ybWF0aW9uLCBzdGFja05hbWU6IHN0cmluZykge1xuICBkZWJ1ZygnV2FpdGluZyBmb3Igc3RhY2sgJXMgdG8gZmluaXNoIGNyZWF0aW5nIG9yIHVwZGF0aW5nLi4uJywgc3RhY2tOYW1lKTtcbiAgcmV0dXJuIHdhaXRGb3IoYXN5bmMgKCkgPT4ge1xuICAgIGNvbnN0IHN0YWNrID0gYXdhaXQgQ2xvdWRGb3JtYXRpb25TdGFjay5sb29rdXAoY2ZuLCBzdGFja05hbWUpO1xuICAgIGlmICghc3RhY2suZXhpc3RzKSB7XG4gICAgICBkZWJ1ZygnU3RhY2sgJXMgZG9lcyBub3QgZXhpc3QnLCBzdGFja05hbWUpO1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGNvbnN0IHN0YXR1cyA9IHN0YWNrLnN0YWNrU3RhdHVzO1xuICAgIGlmIChzdGF0dXMuaXNJblByb2dyZXNzKSB7XG4gICAgICBkZWJ1ZygnU3RhY2sgJXMgaGFzIGFuIG9uZ29pbmcgb3BlcmF0aW9uIGluIHByb2dyZXNzIGFuZCBpcyBub3Qgc3RhYmxlICglcyknLCBzdGFja05hbWUsIHN0YXR1cyk7XG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIHJldHVybiBzdGFjaztcbiAgfSk7XG59XG5cbmV4cG9ydCBjbGFzcyBUZW1wbGF0ZVBhcmFtZXRlcnMge1xuICBwdWJsaWMgc3RhdGljIGZyb21UZW1wbGF0ZSh0ZW1wbGF0ZTogVGVtcGxhdGUpIHtcbiAgICByZXR1cm4gbmV3IFRlbXBsYXRlUGFyYW1ldGVycyh0ZW1wbGF0ZS5QYXJhbWV0ZXJzIHx8IHt9KTtcbiAgfVxuXG4gIGNvbnN0cnVjdG9yKHByaXZhdGUgcmVhZG9ubHkgcGFyYW1zOiBSZWNvcmQ8c3RyaW5nLCBUZW1wbGF0ZVBhcmFtZXRlcj4pIHtcbiAgfVxuXG4gIC8qKlxuICAgKiBDYWxjdWxhdGUgc3RhY2sgcGFyYW1ldGVycyB0byBwYXNzIGZyb20gdGhlIGdpdmVuIGRlc2lyZWQgcGFyYW1ldGVyIHZhbHVlc1xuICAgKlxuICAgKiBXaWxsIHRocm93IGlmIHBhcmFtZXRlcnMgd2l0aG91dCBhIERlZmF1bHQgdmFsdWUgb3IgYSBQcmV2aW91cyB2YWx1ZSBhcmUgbm90XG4gICAqIHN1cHBsaWVkLlxuICAgKi9cbiAgcHVibGljIHRvU3RhY2tQYXJhbWV0ZXJzKHVwZGF0ZXM6IFJlY29yZDxzdHJpbmcsIHN0cmluZyB8IHVuZGVmaW5lZD4pOiBTdGFja1BhcmFtZXRlcnMge1xuICAgIHJldHVybiBuZXcgU3RhY2tQYXJhbWV0ZXJzKHRoaXMucGFyYW1zLCB1cGRhdGVzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBGcm9tIHRoZSB0ZW1wbGF0ZSwgdGhlIGdpdmVuIGRlc2lyZWQgdmFsdWVzIGFuZCB0aGUgY3VycmVudCB2YWx1ZXMsIGNhbGN1bGF0ZSB0aGUgY2hhbmdlcyB0byB0aGUgc3RhY2sgcGFyYW1ldGVyc1xuICAgKlxuICAgKiBXaWxsIHRha2UgaW50byBhY2NvdW50IHBhcmFtZXRlcnMgYWxyZWFkeSBzZXQgb24gdGhlIHRlbXBsYXRlICh3aWxsIGVtaXRcbiAgICogJ1VzZVByZXZpb3VzVmFsdWU6IHRydWUnIGZvciB0aG9zZSB1bmxlc3MgdGhlIHZhbHVlIGlzIGNoYW5nZWQpLCBhbmQgd2lsbFxuICAgKiB0aHJvdyBpZiBwYXJhbWV0ZXJzIHdpdGhvdXQgYSBEZWZhdWx0IHZhbHVlIG9yIGEgUHJldmlvdXMgdmFsdWUgYXJlIG5vdFxuICAgKiBzdXBwbGllZC5cbiAgICovXG4gIHB1YmxpYyBkaWZmKHVwZGF0ZXM6IFJlY29yZDxzdHJpbmcsIHN0cmluZyB8IHVuZGVmaW5lZD4sIHByZXZpb3VzVmFsdWVzOiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+KTogU3RhY2tQYXJhbWV0ZXJzIHtcbiAgICByZXR1cm4gbmV3IFN0YWNrUGFyYW1ldGVycyh0aGlzLnBhcmFtcywgdXBkYXRlcywgcHJldmlvdXNWYWx1ZXMpO1xuICB9XG59XG5cbmV4cG9ydCBjbGFzcyBTdGFja1BhcmFtZXRlcnMge1xuICAvKipcbiAgICogVGhlIENsb3VkRm9ybWF0aW9uIHBhcmFtZXRlcnMgdG8gcGFzcyB0byB0aGUgQ3JlYXRlU3RhY2sgb3IgVXBkYXRlU3RhY2sgQVBJXG4gICAqL1xuICBwdWJsaWMgcmVhZG9ubHkgYXBpUGFyYW1ldGVyczogQ2xvdWRGb3JtYXRpb24uUGFyYW1ldGVyW10gPSBbXTtcblxuICBwcml2YXRlIF9jaGFuZ2VzID0gZmFsc2U7XG5cbiAgY29uc3RydWN0b3IoXG4gICAgcHJpdmF0ZSByZWFkb25seSBwYXJhbXM6IFJlY29yZDxzdHJpbmcsIFRlbXBsYXRlUGFyYW1ldGVyPixcbiAgICB1cGRhdGVzOiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmcgfCB1bmRlZmluZWQ+LFxuICAgIHByZXZpb3VzVmFsdWVzOiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+ID0ge30pIHtcblxuICAgIGNvbnN0IG1pc3NpbmdSZXF1aXJlZCA9IG5ldyBBcnJheTxzdHJpbmc+KCk7XG5cbiAgICBmb3IgKGNvbnN0IFtrZXksIHBhcmFtXSBvZiBPYmplY3QuZW50cmllcyh0aGlzLnBhcmFtcykpIHtcbiAgICAgIC8vIElmIGFueSBvZiB0aGUgcGFyYW1ldGVycyBhcmUgU1NNIHBhcmFtZXRlcnMsIHRoZXkgd2lsbCBhbHdheXMgbGVhZCB0byBhIGNoYW5nZVxuICAgICAgaWYgKHBhcmFtLlR5cGUuc3RhcnRzV2l0aCgnQVdTOjpTU006OlBhcmFtZXRlcjo6JykpIHtcbiAgICAgICAgdGhpcy5fY2hhbmdlcyA9IHRydWU7XG4gICAgICB9XG5cbiAgICAgIGlmIChrZXkgaW4gdXBkYXRlcyAmJiB1cGRhdGVzW2tleV0pIHtcbiAgICAgICAgdGhpcy5hcGlQYXJhbWV0ZXJzLnB1c2goeyBQYXJhbWV0ZXJLZXk6IGtleSwgUGFyYW1ldGVyVmFsdWU6IHVwZGF0ZXNba2V5XSB9KTtcblxuICAgICAgICAvLyBJZiB0aGUgdXBkYXRlZCB2YWx1ZSBpcyBkaWZmZXJlbnQgdGhhbiB0aGUgY3VycmVudCB2YWx1ZSwgdGhpcyB3aWxsIGxlYWQgdG8gYSBjaGFuZ2VcbiAgICAgICAgaWYgKCEoa2V5IGluIHByZXZpb3VzVmFsdWVzKSB8fCB1cGRhdGVzW2tleV0gIT09IHByZXZpb3VzVmFsdWVzW2tleV0pIHtcbiAgICAgICAgICB0aGlzLl9jaGFuZ2VzID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChrZXkgaW4gcHJldmlvdXNWYWx1ZXMpIHtcbiAgICAgICAgdGhpcy5hcGlQYXJhbWV0ZXJzLnB1c2goeyBQYXJhbWV0ZXJLZXk6IGtleSwgVXNlUHJldmlvdXNWYWx1ZTogdHJ1ZSB9KTtcbiAgICAgIH0gZWxzZSBpZiAocGFyYW0uRGVmYXVsdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIG1pc3NpbmdSZXF1aXJlZC5wdXNoKGtleSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKG1pc3NpbmdSZXF1aXJlZC5sZW5ndGggPiAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFRoZSBmb2xsb3dpbmcgQ2xvdWRGb3JtYXRpb24gUGFyYW1ldGVycyBhcmUgbWlzc2luZyBhIHZhbHVlOiAke21pc3NpbmdSZXF1aXJlZC5qb2luKCcsICcpfWApO1xuICAgIH1cblxuICAgIC8vIEp1c3QgYXBwZW5kIGFsbCBzdXBwbGllZCBvdmVycmlkZXMgdGhhdCBhcmVuJ3QgcmVhbGx5IGV4cGVjdGVkICh0aGlzXG4gICAgLy8gd2lsbCBmYWlsIENGTiBidXQgbWF5YmUgcGVvcGxlIG1hZGUgdHlwb3MgdGhhdCB0aGV5IHdhbnQgdG8gYmUgbm90aWZpZWRcbiAgICAvLyBvZilcbiAgICBjb25zdCB1bmtub3duUGFyYW0gPSAoW2tleSwgX106IFtzdHJpbmcsIGFueV0pID0+IHRoaXMucGFyYW1zW2tleV0gPT09IHVuZGVmaW5lZDtcbiAgICBjb25zdCBoYXNWYWx1ZSA9IChbXywgdmFsdWVdOiBbc3RyaW5nLCBhbnldKSA9PiAhIXZhbHVlO1xuICAgIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIE9iamVjdC5lbnRyaWVzKHVwZGF0ZXMpLmZpbHRlcih1bmtub3duUGFyYW0pLmZpbHRlcihoYXNWYWx1ZSkpIHtcbiAgICAgIHRoaXMuYXBpUGFyYW1ldGVycy5wdXNoKHsgUGFyYW1ldGVyS2V5OiBrZXksIFBhcmFtZXRlclZhbHVlOiB2YWx1ZSB9KTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogV2hldGhlciB0aGlzIHNldCBvZiBwYXJhbWV0ZXIgdXBkYXRlcyB3aWxsIGNoYW5nZSB0aGUgYWN0dWFsIHN0YWNrIHZhbHVlc1xuICAgKi9cbiAgcHVibGljIGdldCBjaGFuZ2VkKCkge1xuICAgIHJldHVybiB0aGlzLl9jaGFuZ2VzO1xuICB9XG59Il19